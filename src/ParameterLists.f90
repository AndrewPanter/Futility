!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
!                          Futility Development Group                          !
!                             All rights reserved.                             !
!                                                                              !
! Futility is a jointly-maintained, open-source project between the University !
! of Michigan and Oak Ridge National Laboratory.  The copyright and license    !
! can be found in LICENSE.txt in the head directory of this repository.        !
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
!> @brief This module defines a parameter type object.
!>
!> The purpose of this object is to facilitate encapsulation of an arbitrary
!> number of parameters that may have varying types of values into one object
!> which can be more easily passed around between different code.
!>
!> The object is self-referential which means it can contain objects of the
!> same type as itself. This allows for nested lists of parameters. A parameter
!> is defined by a name, a datatype, an optional description, and a value.
!> The value attribute is polymorphic so that it can be a single integer
!> or an array of double precision reals or a list of other parameters.
!>
!> This module only makes public the tree parameter type and it's assignment
!> operation and the exception handler for the module. The tree parameter
!> type includes methods for adding a specific type, editing the contents of
!> parameter tree, clearing the contents of a parameter tree, getting or
!> setting values of existing parameters (or subparameters) and the ability to
!> add or delete parameters nested within other parameters.  The module also
!> makes public the @c ParamTypeIterator that can be used to iterate through
!> all subparameters of a particular location.
!>
!> The parameters are searched and matched using the name attribute and the
!> matching is not case sensitive.
!>
!> The supported extended parameter types accepts every combination of
!> value and rank for values LOGICAL(SBK), INTEGER(SNK), INTEGER(SLK),
!> REAL(SSK), REAL(SDK), and TYPE(StringType) for ranks 0-7.  The code
!> for these combinations is generated by an external python script
!> and included in the source via #include statements.  Additions to
!> the python script can be used to add additional types and ranks as
!> appropriate.  The python script is located in
!> @c Futility/src/parameter_list_includes/generateParameterListClasses.py
!> and should be executed in that directory if updates are required.
!>
!> When passing any path to a @c ParamType method, one can use either a single
!> element, e.g. @c "param1", or a full path to the parameter, e.g.
!> @c "param4->param3->param2->param1".  A partial path such as @c "param2->param1"
!> will fail to find the parameter.  Specifying only the parameter name is strongly
!> discouraged unless the tree is known to be very small; a depth-first search
!> will be used to find the parameter when a full path is not provided, and this
!> can be extremely slow for large trees and potentially find the incorrect parameter
!> if similar structures occur throughout the large tree.
!>
!> The following parameter list @c plist will be used for some examples:
!> @code
!>   A -> A1 -> A2
!>     -> B1 -> B2
!>           -> B3
!>   C -> D1 -> D2
!>           -> D3
!>           -> D4
!> @endcode
!>
!> To retreive a sublist @c sublist from @c plist, use @c plist%get("A->B1",sublist).
!> This will result in the following:
!> @code
!>   B1 -> B2
!>      -> B3
!> @endcode
!> The root can also be neglected with @c plist%get("A->B1",sublist,INCLUDEROOT=.FALSE.).
!> This results in the following:
!>   B2
!>   B3
!> @endcode
!> This option allows the client to eliminate unnecessary levels of hierarchy when retrieving
!> a sublist.  Note that a pointer to a sublist cannot be retrieved, so a copy will always
!> be made.  If many sublists are required, it may be better to use and iterator and combine
!> with a prefix to the current iterator path to directly access parameters on the original
!> list.  This may be more efficient and save memory.
!>
!> To iterate over @c plist, a @c ParamTypeIterator may be used.  There are 2 ways to
!> obtain an iterator.
!>
!> First, @c plist%get("A",iterator) will
!> obtain an iterator that will loop over all sub elements of @c "A" at the first level.
!> While iterating, @c iterator%advance() will iterate to the next parameter.
!> @c iterator%isActive will be @c .TRUE. until @c iterator has passed the last element.
!> For this example, the iterator will travers @c "A1" and @c "B1"; the order that the
!> parameters in a given level of the tree are accessed is determined by the hash of the
!> name, so the parameters will likely not be access in the order stated.
!>
!> There is an optional argument @c SUBLISTS that can be used when retrieving an iterator.
!> The default value for this is @c .FALSE.  If set to @c .TRUE., then the iterator will
!> traverse all elements of all levels, instead of only the first leve.  If called like
!> @c plist%get("A",iterator,SUBLSITS=.TRUE.), the iterator will travserse
!> @c "A1->A2", @c "A1", @c "B1->B2", @c "B1->B3", and @c "B1" if @c SUBLISTS=.TRUE. is used.
!>
!> Second, the iterator could also be activated using @c iterator%activate(plist).  This will
!> loop over the @c plist at the lowest level, traversing @c "A" and @c "C".  The optional
!> argument @c SUBLISTS is also available in this interface and has the same behavior.
!>
!> The iterator has methods @c getCurrentName and @c getCurrentType that can be
!> used to query the current iterate.  The @c getCurrentName method has an optional
!> argument @c fullPath that defaults to @c .TRUE.  This argument is only applicable
!> when the iterator was initialized with @c SUBLISTS=.TRUE.  Returning to the previous
!> examples, @c getCurrentName(string) would return something like @c "A->A1->A2" where
!> @c getCurrentname(string,FULLPATH=.FALSE.) would return only @c "A2".
!>
!> Parameters and trees can also be copied to one another.  Here's an example, once
!> again using @c plist from above.
!> @code
!>    plist2 = plist
!>    CALL plist%copyParam("A->B1","C",plist2)
!> @code
!> This copies everything under @c "A->B1" on @c plist to be under @c "C" on
!> @c plist2, resulting in the following for @c plist2:
!> @code
!>   A -> A1 -> A2
!>     -> B1 -> B2
!>           -> B3
!>   C -> D1 -> D2
!>           -> D3
!>           -> D4
!>     -> B2
!>     -> B3
!> @endcode
!> Note that the root @c "A->B1" from the source @c plist is not included.
!> This is an optional argument @c OVERWITE which defaults to false.  If this
!> argument is not supplied, and there already exists a parameter on the target
!> whose name matches the one that needs to be copied, an error will be thrown
!> and the routine will return early.  Setting @c OVERWRITE=.TRUE. will cause
!> the code to replace the pre-existing parameter if needed.  Any other parameters
!> that exist alongside the newly copied ones will be retained; in the above example,
!> that means that even with @c OVERWRITE=.TRUE. there will not be an attempt to
!> remove @c "C->D1" from @c plist2 since it does not conflict with the incoming
!> parameters.  If the source path in @c plist does not exist in @c plist, then
!> nothing is done; no errors are thrown in this case.
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++!
MODULE ParameterLists
#include "UnitTest.h"
#include "Futility_DBC.h"
USE ISO_FORTRAN_ENV
USE Futility_DBC
USE HashModule
USE UnitTest
USE IntrType
USE Strings
USE ExceptionHandler
USE IO_Strings
USE FileType_HDF5
USE FileType_XML
#ifdef FUTILITY_HAVE_Trilinos
USE ForTeuchos_ParameterList
#endif

IMPLICIT NONE
PRIVATE !Default private for module contents
!
! List of Public items
PUBLIC :: eParams
PUBLIC :: ParamType
PUBLIC :: ParamNode
PUBLIC :: ParamTypeIterator
PUBLIC :: ASSIGNMENT(=)
PUBLIC :: OPERATOR(==)

!> The module name
CHARACTER(LEN=*),PARAMETER :: modName='PARAMETERLISTS'
INTEGER(SIK),PARAMETER :: MAX_1D_LEN=10

!> Verification enumerations
INTEGER(SIK),PARAMETER :: VALIDTYPE_VALIDATE=0
INTEGER(SIK),PARAMETER :: VALIDTYPE_VERIFYTEST=1
INTEGER(SIK),PARAMETER :: VALIDTYPE_VERIFYLIST=2

!> Hashing parameters
INTEGER(SLK),PARAMETER,PRIVATE :: PL_HASH_POLYNOMIAL_BASE=97_SIK
INTEGER(SLK),PARAMETER,PRIVATE :: PL_HASH_MODULUS=1000000009_SIK

!> Exception handler for the module
TYPE(ExceptionHandlerType),SAVE :: eParams

!> Inerface for different uses of get_hash_list
INTERFACE get_hash_list
  MODULE PROCEDURE get_hash_list_string
  MODULE PROCEDURE get_hash_list_string_array
ENDINTERFACE get_hash_list

!> @brief Abstract type for a parameter
!>
!> Extensions of this object can add data to it so
!> it can represent various types of data.
TYPE,ABSTRACT :: Param_Base
  CONTAINS
    !> @copybrief ParameterLists::clearParam
    !> @copydetails ParameterLists::clearParam
    PROCEDURE,PASS :: clear => clearParam
    !> @copybrief ParameterLists::getString
    !> @copydetails ParameterLists::getString
    PROCEDURE,PASS :: getString
    !> @copybrief ParameterLists::editBaseToText
    !> @copydetails ParameterLists::editBaseToText
    PROCEDURE,PASS,PRIVATE :: editToText => editBaseToText
    !> @copybrief ParameterLists::editBaseToH5
    !> @copydetails ParameterLists::editBaseToH5
    PROCEDURE,PASS,PRIVATE :: editToH5 => editBaseToH5
    !> @copybrief ParameterLists::readBaseFromH5
    !> @copydetails ParameterLists::readBaseFromH5
    PROCEDURE,PASS,PRIVATE :: readFromH5 => readBaseFromH5
ENDTYPE Param_Base

#include "parameter_list_includes/parameterListClasses.f90"

!> @brief defines a single node in the binary tree of parameters
!>
!> This class defines the node in the binary tree used to traverse
!> a tree of parameters.  The node itself is data type agnostic.
!> It becomes associated with a particular type through the allocation
!> of its @c val component.
TYPE :: ParamNode
  PRIVATE
  !> Initialization status
  LOGICAL(SBK) :: isInit=.FALSE.
  !> Integer hash of the name, used for fast searching
  INTEGER(SLK) :: upperNameHash=0_SLK
  !> Name of the node
  TYPE(StringType) :: name
  !> Description of the node
  TYPE(StringType) :: description
  !> The data type of the node; @c PL_DATA_TYPE_NULL if @c val is unallocated
  INTEGER(SIK) :: dataType=PL_DATA_TYPE_NULL
  !> The concrete data associated with the node, via a @c Param_Base extension
  CLASS(Param_Base),ALLOCATABLE :: val
  !> The node's left node
  CLASS(ParamNode),POINTER :: left => NULL()
  !> The node's right node
  CLASS(ParamNode),POINTER :: right => NULL()
  !> The node's parent node
  CLASS(ParamNode),POINTER :: parent => NULL()
  CONTAINS
    !> @copybrief ParameterLists::initBase
    !> @copydetails ParameterLists::initBase
    PROCEDURE,PASS,NON_OVERRIDABLE :: initBase
    !> @copybrief ParameterLists::initTree
    !> @copydetails ParameterLists::initTree
    PROCEDURE,PASS,NON_OVERRIDABLE :: initTree
    !> @copybrief ParameterLists::initTree_pointer
    !> @copydetails ParameterLists::initTree_pointer
    PROCEDURE,PASS,NON_OVERRIDABLE :: initTree_pointer
#include "parameter_list_includes/parameterListInitMethods.f90"
    !> @copybrief ParameterLists::renameParam
    !> @copydetails ParameterLists::renameParam
    PROCEDURE,PASS,NON_OVERRIDABLE :: rename => renameParam
    !> @copybrief ParameterLists::clearNode
    !> @copydetails ParameterLists::clearNode
    PROCEDURE,PASS,NON_OVERRIDABLE :: clearNode
    !> @copybrief ParameterLists::editNodeToText
    !> @copydetails ParameterLists::editNodeToText
    PROCEDURE,PASS,NON_OVERRIDABLE :: editNodeToText
    !> @copybrief ParameterLists::editNodeToH5
    !> @copydetails ParameterLists::editNodeToH5
    PROCEDURE,PASS,NON_OVERRIDABLE :: editNodeToH5
    !> Generic procedures for editing a @c ParamNode
    GENERIC :: edit => editNodeToText,editNodeToH5
    !> @copybrief ParameterLists::readNodeFromH5
    !> @copydetails ParameterLists::readNodeFromH5
    PROCEDURE,PASS,NON_OVERRIDABLE :: readNodeFromH5
ENDTYPE ParamNode

!> @brief defines an iterator over a @c ParamType
!>
!> The iterator starts at the leftmost node of the tree
!> and iterates to the subsequent node according to the
!> hach values of each node.  It ensures every node in
!> the level is visited.
!>
!> Support for sub-iterators allows iterating through
!> lower level trees if a particular node's data type
!> is actually another tree.
TYPE :: ParamTypeIterator
  PRIVATE
  LOGICAL(SBK),PUBLIC :: isActive=.FALSE.
  LOGICAL(SBK),PUBLIC :: iterateSubLists=.TRUE.
  TYPE(StringType) :: name
  INTEGER(SIK) :: dataType=PL_DATA_TYPE_NULL
  CLASS(ParamNode),POINTER :: node => NULL()
  CLASS(ParamType),POINTER :: tree => NULL()
  TYPE(ParamTypeIterator),POINTER :: subIter => NULL()
  CONTAINS
    !> @copybrief ParameterLists::activate
    !> @copydetails ParameterLists::activate
    PROCEDURE,PASS :: activate
    !> @copybrief ParameterLists::advance
    !> @copydetails ParameterLists::advance
    PROCEDURE,PASS :: advance
    !> @copybrief ParameterLists::getCurrentName
    !> @copydetails ParameterLists::getCurrentName
    PROCEDURE,PASS :: getCurrentName
    !> @copybrief ParameterLists::getCurrentType
    !> @copydetails ParameterLists::getCurrentType
    PROCEDURE,PASS :: getCurrentType
    !> @copybrief ParameterLists::getCurrentNode
    !> @copydetails ParameterLists::getCurrentNode
    PROCEDURE,PASS :: getCurrentNode
    !> @copybrief ParameterLists::clearIterator
    !> @copydetails ParameterLists::clearIterator
    PROCEDURE,PASS :: clear => clearIterator
    PROCEDURE,NOPASS :: getNextNode
    !> @copybrief ParameterLists::editIteratorToH5
    !> @copydetails ParameterLists::editIteratorToH5
    PROCEDURE,PASS,PRIVATE :: editIteratorToH5
    !> @copybrief ParameterLists::editIteratorToH5
    !> @copydetails ParameterLists::editIteratorToH5
    PROCEDURE,PASS :: edit => editIteratorToH5
ENDTYPE ParamTypeIterator

!> @brief defines a binary tree of @c ParamNode objects
!>
!> The @c root of the tree is merely the first node added
!> to it.  From the @c root, additional nodes are added
!> as left or right leaves to build a binary tree.  The
!> @c has, @c remove, @c get, @c add, @c set, and other
!> methods use binary tree traversal to quickly identify
!> the proper node for which data is needed.
TYPE,EXTENDS(Param_Base) :: ParamType
  PRIVATE
  CLASS(ParamNode),POINTER :: root => NULL()
  CONTAINS
    !Client-facing routines
    !> @copybrief ParameterLists::clearTree
    !> @copydetails ParameterLists::clearTree
    PROCEDURE,PASS :: clear => clearTree
    !> @copybrief ParameterLists::has
    !> @copydetails ParameterLists::has
    PROCEDURE,PASS :: has
    !> @copybrief ParameterLists::remove
    !> @copydetails ParameterLists::remove
    PROCEDURE,PASS :: remove
    !> @copybrief ParameterLists::getName
    !> @copydetails ParameterLists::getName
    PROCEDURE,PASS :: getName
    !> @copybrief ParameterLists::getNameHash
    !> @copydetails ParameterLists::getNameHash
    PROCEDURE,PASS :: getNameHash
    !> @copybrief ParameterLists::getDescription
    !> @copydetails ParameterLists::getDescription
    PROCEDURE,PASS :: getDescription
    !> @copybrief ParameterLists::getDataType
    !> @copydetails ParameterLists::getDataType
    PROCEDURE,PASS :: getDataType
    !> @copybrief ParameterLists::copyParam
    !> @copydetails ParameterLists::copyParam
    PROCEDURE,PASS :: copyParam
    !
#include "parameter_list_includes/parameterListGenerics.f90"
    !> @copybrief ParameterLists::initFromXML
    !> @copydetails ParameterLists::initFromXML
    PROCEDURE,PASS :: initFromXML
    !> @copybrief ParameterLists::convertTo2DStringArray
    !> @copydetails ParameterLists::convertTo2DStringArray
    PROCEDURE,PASS :: convertTo2DStringArray
    !> @copybrief ParameterLists::validate
    !> @copydetails ParameterLists::validate
    PROCEDURE,PASS :: validate
    !> @copybrief ParameterLists::verify
    !> @copydetails ParameterLists::verify
    PROCEDURE,PASS :: verify
    !> @copybrief ParameterLists::editTreeToText
    !> @copydetails ParameterLists::editTreeToText
    PROCEDURE,PASS,PRIVATE :: editTreeToText
    !> @copybrief ParameterLists::editToH5_Tree
    !> @copydetails ParameterLists::editToH5_Tree
    PROCEDURE,PASS,PRIVATE :: editToH5 => editToH5_Tree
    !> Generic procedures for editing a @c ParamType
    GENERIC :: edit => editTreeToText,editToH5
    !> @copybrief ParameterLists::readFromH5_Tree
    !> @copydetails ParameterLists::readFromH5_Tree
    PROCEDURE,PASS,PRIVATE :: readFromH5 => readFromH5_Tree
    !> Generic procedures for reading a @c ParamType
    GENERIC :: read => readFromH5
    !> @copybrief ParameterLists::editToXML
    !> @copydetails ParameterLists::editToXML
    PROCEDURE,PASS :: editToXML
#ifdef FUTILITY_HAVE_Trilinos
    !> @copybrief ParameterLists::toTeuchosPlist
    !> @copydetails ParameterLists::toTeuchosPlist
    PROCEDURE,PASS :: toTeuchosPlist
#endif
    !Private routines for tree traversal
    !> @copybrief ParameterLists::getTreeNode
    !> @copydetails ParameterLists::getTreeNode
    PROCEDURE,PASS,PRIVATE :: getTreeNode
    !> @copybrief ParameterLists::getOrCreateNode_Name
    !> @copydetails ParameterLists::getOrCreateNode_Name
    PROCEDURE,PASS,PRIVATE :: getOrCreateNode_Name
    !> @copybrief ParameterLists::getOrCreateNode_Hashes
    !> @copydetails ParameterLists::getOrCreateNode_Hashes
    PROCEDURE,PASS,PRIVATE :: getOrCreateNode_Hashes
    !> @copybrief ParameterLists::getNode_Name
    !> @copydetails ParameterLists::getNode_Name
    PROCEDURE,PASS,PRIVATE :: getNode_Name
    !> @copybrief ParameterLists::getNode_Hashes
    !> @copydetails ParameterLists::getNode_Hashes
    PROCEDURE,PASS,PRIVATE :: getNode_Hashes
    !> @copybrief ParameterLists::editToText_Tree
    !> @copydetails ParameterLists::editToText_Tree
    PROCEDURE,PASS,PRIVATE :: editToText => editToText_Tree
ENDTYPE ParamType

!> Defines the assignment operator for @c paramNode and @c paramType
!> classes using deep copy procedures
INTERFACE ASSIGNMENT(=)
  MODULE PROCEDURE :: assign_paramNode
  MODULE PROCEDURE :: assign_paramType
ENDINTERFACE

!> Defines the equals interface for the @c paramBase object
INTERFACE OPERATOR(==)
  MODULE PROCEDURE :: equals_paramBase
ENDINTERFACE
!
!===============================================================================
CONTAINS
!===============================================================================
! Helper routines to support hashing
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Generates a list of hashes for a parameter list path
!> @param name the path to the parameter list
!> @param hashes the returned list of hashed values
!>
!> The size of @c hashes will be one greater than the number of @c '->' in the path
!>
SUBROUTINE get_hash_list_string(name,hashes)
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SLK),ALLOCATABLE,INTENT(OUT) :: hashes(:)
  !
  INTEGER(SIK) :: i
  TYPE(StringType) :: strname
  TYPE(StringType),ALLOCATABLE :: names(:)

  strname=TRIM(ADJUSTL(name))
  names=strname%split('->')
  ALLOCATE(hashes(SIZE(names)))
  DO i=1,SIZE(hashes)
    hashes(i)=stringHash(TRIM(ADJUSTL(names(i)%upper())),PL_HASH_POLYNOMIAL_BASE,PL_HASH_MODULUS)
  ENDDO !i

ENDSUBROUTINE get_hash_list_string
!
!-------------------------------------------------------------------------------
!> @brief Generates a list of hashes for a parameter list path
!> @param names the path to the parameter list, split at '->'
!> @param hashes the returned list of hashed values
!>
!> The size of @c hashes will equal to the size of @c names
!>
SUBROUTINE get_hash_list_string_array(names,hashes)
  TYPE(StringType),INTENT(IN) :: names(:)
  INTEGER(SLK),ALLOCATABLE,INTENT(OUT) :: hashes(:)
  !
  INTEGER(SIK) :: i

  ALLOCATE(hashes(SIZE(names)))
  DO i=1,SIZE(hashes)
    hashes(i)=stringHash(TRIM(ADJUSTL(names(i)%upper())),PL_HASH_POLYNOMIAL_BASE,PL_HASH_MODULUS)
  ENDDO !i

ENDSUBROUTINE get_hash_list_string_array
!
!===============================================================================
! Helper routines to support tree traversal
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Removes a node from a tree
!> @param node the node that was removed from the tree
!> @param hash the has of the node, used to re-link the tree correctly
!>
!> The removal algorithm in this routine is taken from
!> https://helloacm.com/how-to-delete-a-node-from-a-binary-search-tree/
!>
RECURSIVE SUBROUTINE removeNode(node,hash)
CLASS(ParamNode),POINTER,INTENT(INOUT) :: node
INTEGER(SLK),INTENT(IN) :: hash
!
CLASS(ParamNode),POINTER :: tmp

IF(.NOT.ASSOCIATED(node)) RETURN

IF(hash < node%upperNameHash) THEN
  CALL removeNode(node%left,hash)
ELSEIF(hash > node%upperNameHash) THEN
  CALL removeNode(node%right,hash)
ELSE
  !No children
  IF(.NOT.ASSOCIATED(node%left) .AND. .NOT.ASSOCIATED(node%right)) THEN
    CALL node%clearNode(.TRUE.)
    DEALLOCATE(node)
    node => NULL()
  !Right child
  ELSEIF(.NOT.ASSOCIATED(node%left)) THEN
    tmp => node
    node => node%right
    node%parent => tmp%parent
    CALL tmp%clearNode(.FALSE.)
    DEALLOCATE(tmp)
  !Left child
  ELSEIF(.NOT.ASSOCIATED(node%right)) THEN
    tmp => node
    node => node%left
    node%parent => tmp%parent
    CALL tmp%clearNode(.FALSE.)
    DEALLOCATE(tmp)
  !Two children
  ELSE
    CALL getLeftmostNode(node%right,tmp)
    CALL copy_node_data(node,tmp)
    CALL removeNode(node%right,tmp%upperNameHash)
  ENDIF
ENDIF

ENDSUBROUTINE removeNode
!
!-------------------------------------------------------------------------------
!> @brief retrieves the leftmost node at or nuder a specified starting node
!> @param start the starting node to search under
!> @param leftmost the leftmost node found in the search
!>
SUBROUTINE getLeftmostNode(start,leftmost)
  CLASS(ParamNode),TARGET,INTENT(IN) :: start
  CLASS(ParamNode),POINTER,INTENT(OUT) :: leftmost

  leftmost => start
  IF(.NOT.ASSOCIATED(leftmost)) RETURN
  DO WHILE(ASSOCIATED(leftmost%left))
    leftmost => leftmost%left
  ENDDO

ENDSUBROUTINE getLeftmostNode
!
!===============================================================================
! Helper routines to support error checking
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Checks for errors related to @c get methods
!> @param node the node identified by the calling procedure
!> @param default whether or not a default value was provided for a missing node
!> @param name the name of the node to search for
!> @param dataType the data type being retrieved by the calling procedure
!> @returns code the resulting error code; 0 means no error
!>
FUNCTION errorChecks_get(node,default,name,dataType) RESULT(code)
  CLASS(ParamNode),POINTER,INTENT(IN) :: node
  LOGICAL(SBK),INTENT(IN) :: default
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SIK),INTENT(IN) :: dataType
  INTEGER(SIK) :: code
  !
  CHARACTER(LEN=*),PARAMETER :: myName='errorChecks_get'

  IF(.NOT.ASSOCIATED(node)) THEN
    IF(default) then
      code = 0
    ELSE
      CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" of type "'// &
          TRIM(paramTypeNames(dataType))//'" could not be found!')
      code = 1
    ENDIF
  ELSEIF(node%dataType /= dataType) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" exists but is of type "'// &
        TRIM(paramTypeNames(node%dataType))//'" instead of the requested type "'//TRIM(paramTypeNames(dataType))//'"!')
    code = 2
  ELSE
    code = 0
  ENDIF

ENDFUNCTION errorChecks_get
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a @c ParamType from a @c ParamType
!> @param this the @c ParamType to search
!> @param name the path to search for
!> @param val the resulting @c ParamType located at @c name
!> @param includeRoot indicates if the root @c name should be included at the top
!>        of @c val; optional, defaults to @c .TRUE.
!>
SUBROUTINE getTree(this,name,val,includeRoot)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CLASS(ParamType),TARGET,INTENT(INOUT) :: val
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: includeRoot
  !
  LOGICAL(SBK) :: lRoot
  TYPE(ParamType),TARGET :: tmpTree
  CLASS(ParamType),POINTER :: paramPtr
  CLASS(ParamNode),POINTER :: node

  lRoot = .TRUE.
  IF(PRESENT(includeRoot)) lRoot = includeRoot

  CALL val%clear()
  CALL this%getNode_Name(name,node)
  IF(errorChecks_get(node,.FALSE.,name,PL_DATA_TYPE_TREE) == 0) THEN
    IF(lRoot) THEN
      paramPtr => tmpTree
    ELSE
      paramPtr => val
    ENDIF
    SELECTTYPE(ptr => node%val); TYPE IS(ParamType)
      paramPtr = ptr
    ENDSELECT
    IF(lRoot) THEN
      IF(INDEX(name,'->') > 0) THEN
        CALL val%add(name(INDEX(name,'->',BACK=.TRUE.)+2:),tmpTree)
      ELSE
        CALL val%add(name,tmpTree)
      ENDIF
      CALL tmpTree%clear()
    ENDIF
  ENDIF

ENDSUBROUTINE getTree
!
!-------------------------------------------------------------------------------
!> @brief Retrieves an iterator over a portion of a @c ParamType
!> @param this the @c ParamType to iterate over
!> @param name the path to iterate over
!> @param iterator the resulting iterator
!> @param sublists logical indicating if @c iterator should also iterate over
!>        sublists contained in @c name; optional, default to @c .FALSE.
!>
SUBROUTINE getIterator(this,name,iterator,sublists)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  TYPE(ParamTypeIterator),INTENT(INOUT) :: iterator
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: sublists
  !
  LOGICAL(SBK) :: lsublists
  CLASS(ParamNode),POINTER :: node

  lsublists = .FALSE.
  IF(PRESENT(sublists)) lsublists = sublists

  CALL this%getNode_Name(name,node)
  CALL iterator%clear()
  IF(ASSOCIATED(node)) THEN
    SELECTTYPE(val => node%val); TYPE IS(ParamType)
      CALL iterator%activate(val,SUBLISTS=lsublists)
    ENDSELECT
  ENDIF

ENDSUBROUTINE getIterator
!
!-------------------------------------------------------------------------------
!> @brief Checks for errors related to @c set methods
!> @param node the node identified by the calling procedure
!> @param addMissing whether or not to @c add the value if @c node was not found
!> @param name the name of the node to search for
!> @param dataType the data type being set by the calling procedure
!> @returns code the resulting error code; 0 means no error
!>
FUNCTION errorChecks_set(node,addmissing,name,dataType) RESULT(code)
  CLASS(ParamNode),POINTER,INTENT(IN) :: node
  LOGICAL(SBK),INTENT(IN) :: addmissing
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SIK),INTENT(IN) :: dataType
  INTEGER(SIK) :: code
  !
  CHARACTER(LEN=*),PARAMETER :: myName='errorChecks_set'

  IF(.NOT.ASSOCIATED(node)) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" of type "'// &
        TRIM(paramTypeNames(dataType))//'" could not be found!  Either set addmissing=.TRUE. or '// &
        'use add method.')
    code=1
  ELSEIF(.NOT.ALLOCATED(node%val) .AND. .NOT.addmissing) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" of type "'// &
        TRIM(paramTypeNames(dataType))//'" is not allocated!  Either set addmissing=.TRUE. or '// &
        'use add method.')
    code=2
  ELSEIF(node%dataType /= dataType) THEN
    IF(node%dataType == PL_DATA_TYPE_NULL .AND. addmissing) THEN
      code = 0
    ELSE
      CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" of type "'// &
          TRIM(paramTypeNames(dataType))//'" already exists!  Cannot add'//TRIM(paramTypeNames(node%datatype))// &
          ' value.  Try removing parameter first or using correct type.')
      code=3
    ENDIF
  ELSE
    code=0
  ENDIF

ENDFUNCTION errorChecks_set
!
!-------------------------------------------------------------------------------
!> @brief Checks for errors related to @c add methods
!> @param node the node identified by the calling procedure
!> @param name the name of the node to search for
!> @param dataType the data type being added by the calling procedure
!> @returns code the resulting error code; 0 means no error
!>
FUNCTION errorChecks_add(node,name,dataType) RESULT(code)
  CLASS(ParamNode),POINTER,INTENT(IN) :: node
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SIK),INTENT(IN) :: dataType
  INTEGER(SIK) :: code
  !
  CHARACTER(LEN=*),PARAMETER :: myName='errorChecks_add'

  IF(.NOT.ASSOCIATED(node)) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Parameter node "'//name//'" of type "'// &
        TRIM(paramTypeNames(dataType))//'" was not properly created!')
    code = 1
  ELSEIF(ALLOCATED(node%val)) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Parameter "'//name//'" of type "'// &
        TRIM(paramTypeNames(dataType))//'" already exists!  Cannot add Tree value.'  // &
        '  Try removing parameter or using set.')
    code = 2
  ELSE
    code = 0
  ENDIF

ENDFUNCTION errorChecks_add
!
!===============================================================================
! Operator definitions
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Defines a node copy between 2 @c ParamNode objects
!> @param lhs the target @c ParamNode
!> @param rhs the source @c ParamNode
!>
!> All data about the node itself is copied, but pointers to @c left, @c right,
!> and @c parent are not copied.
!>
SUBROUTINE copy_node_data(lhs,rhs)
  CLASS(ParamNode),INTENT(INOUT) :: lhs
  CLASS(ParamNode),INTENT(IN) :: rhs
  !
  LOGICAL(SBK) :: lset

  lhs%isInit = rhs%isInit
  lhs%upperNameHash = rhs%upperNameHash
  lhs%name = rhs%name
  lhs%description = rhs%description
  lhs%dataType = rhs%dataType
  IF(ALLOCATED(lhs%val)) THEN
    CALL lhs%val%clear()
    DEALLOCATE(lhs%val)
  ENDIF
  IF(ALLOCATED(rhs%val)) THEN
    ALLOCATE(lhs%val,MOLD=rhs%val)
    lset = .TRUE.
    SELECTTYPE(v1 => rhs%val); CLASS IS(ParamType)
      SELECTTYPE(v2 => lhs%val); CLASS IS(ParamType)
        CALL assign_ParamType(v2,v1)
        lset = .FALSE.
      ENDSELECT
    ENDSELECT
    IF(lset) lhs%val = rhs%val
  ENDIF

ENDSUBROUTINE copy_node_data
!
!-------------------------------------------------------------------------------
!> @brief copies the node's metadata
!> @param lhs the target @c ParamNode
!> @param rhs the source @c ParamNode
!>
SUBROUTINE assign_ParamNodeMetadta(lhs,rhs)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: lhs
  CLASS(ParamNode),INTENT(IN) :: rhs

  lhs%description = rhs%description
  lhs%dataType = rhs%dataType

ENDSUBROUTINE assign_ParamNodeMetadta
!
!-------------------------------------------------------------------------------
!> @brief Performs a deep copy of a node
!> @param lhs the target @c ParamNode
!> @param rhs the source @c ParamNode
!>
!> The @c left, @c right, and @c parent are all deep-copied; the routine is called
!> recursively as necessary to continue copying lower @c ParamType levels.
!>
RECURSIVE SUBROUTINE assign_paramNode(lhs,rhs)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: lhs
  CLASS(ParamNode),INTENT(IN) :: rhs
  !
  LOGICAL(SBK) :: lset

  CALL lhs%clearNode(.TRUE.)
  lhs%isInit = rhs%isInit
  lhs%upperNameHash = rhs%upperNameHash
  lhs%name = rhs%name
  CALL assign_ParamNodeMetadta(lhs,rhs)
  IF(ALLOCATED(lhs%val)) THEN
    CALL lhs%val%clear()
    DEALLOCATE(lhs%val)
  ENDIF
  IF(ALLOCATED(rhs%val)) THEN
    ALLOCATE(lhs%val,MOLD=rhs%val)
    lset = .TRUE.
    SELECTTYPE(v1 => rhs%val); CLASS IS(ParamType)
      SELECTTYPE(v2 => lhs%val); CLASS IS(ParamType)
        CALL assign_ParamType(v2,v1)
        lset = .FALSE.
      ENDSELECT
    ENDSELECT
    IF(lset) lhs%val = rhs%val
  ENDIF
  IF(ASSOCIATED(rhs%left)) THEN
    ALLOCATE(lhs%left)
    lhs%left = rhs%left
    lhs%left%parent => lhs
  ENDIF
  IF(ASSOCIATED(rhs%right)) THEN
    ALLOCATE(lhs%right)
    lhs%right = rhs%right
    lhs%right%parent => lhs
  ENDIF

ENDSUBROUTINE assign_paramNode
!
!-------------------------------------------------------------------------------
!> @brief Deep copies a @c ParamType
!> @param lhs the target @c ParamType
!> @param rhs the source @c ParamType
!>
RECURSIVE SUBROUTINE assign_ParamType(lhs,rhs)
  CLASS(ParamType),TARGET,INTENT(INOUT) :: lhs
  CLASS(ParamType),INTENT(IN) :: rhs

  CALL lhs%clear()
  IF(ASSOCIATED(rhs%root)) THEN
    ALLOCATE(lhs%root)
    lhs%root = rhs%root
  ENDIF

ENDSUBROUTINE assign_ParamType
!
!-------------------------------------------------------------------------------
#include "parameter_list_includes/parameterListEquality.f90"
!
!===============================================================================
! Methods for the Param_Base class
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Defines the clear interface for a @c Param_Base
RECURSIVE SUBROUTINE clearParam(this)
  CLASS(Param_Base),INTENT(INOUT) :: this
ENDSUBROUTINE clearParam
!
!-------------------------------------------------------------------------------
!> @brief Edits a @c Param_Base to a text file
!> @param this the @c Param_Base to edit
!> @param funit the file unit number
!> @param indent the number of indentations preceding the parameter
!> @param prefix unused
!> @param shift unused
!> @param description the description to append to the parameter edit
!> @param paddtw unused
!>
SUBROUTINE editBaseToText(this,funit,indent,prefix,shift,description,paddtw)
  CLASS(Param_Base),INTENT(IN) :: this
  INTEGER(SIK),INTENT(IN) :: funit
  INTEGER(SIK),INTENT(IN) :: indent
  TYPE(StringType),INTENT(IN) :: prefix
  INTEGER(SIK),INTENT(IN) :: shift
  CHARACTER(LEN=*),INTENT(IN) :: description
  LOGICAL(SBK),INTENT(IN) :: paddtw

  WRITE(UNIT=funit,FMT='(a)') ' ! '//description

ENDSUBROUTINE editBaseToText
!
!-------------------------------------------------------------------------------
!> @brief Defines the interface to edit a @c Param_Base to an HDF5 file
!> @param this the @c Param_Base to edit
!> @param file the @c HDF5FileType object to write to
!> @param path the location in @c file to write
!>
SUBROUTINE editBaseToH5(this,file,path)
  CLASS(Param_Base),INTENT(IN) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path
  !
  CHARACTER(LEN=*),PARAMETER :: myName='editBaseToH5'

  CALL eParams%raiseError(modName//'::'//myName//' - This method is not implemented and must be overridden!')

ENDSUBROUTINE editBaseToH5
!
!-------------------------------------------------------------------------------
!> @brief Defines the interface to read a @c Param_Base from an HDF5 file
!> @param this the @c Param_Base to read
!> @param file the @c HDF5FileType object to read from
!> @param path the location in @c file read from
!>
SUBROUTINE readBaseFromH5(this,file,path)
  CLASS(Param_Base),INTENT(INOUT) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path
  !
  CHARACTER(LEN=*),PARAMETER :: myName='readBaseFromH5'

  CALL eParams%raiseError(modName//'::'//myName//' - This method is not implemented and must be overridden!')

ENDSUBROUTINE readBaseFromH5
!
!===============================================================================
! Methods for the Param Node
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Initialize the base components of a @c ParamNode
SUBROUTINE initBase(this,name,description)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description

  CALL this%rename(name,description)
  this%isInit=.TRUE.

ENDSUBROUTINE initBase
!
!-------------------------------------------------------------------------------
!> @brief Initialize a @c ParamNode to contain a @c ParamType
!> @param this the node to initialize
!> @param name the name of the node
!> @param val the @c paramType to use; optional, only allocated @c val if not present
!> @param description the node's description; optional, defaults to empty string
!>
SUBROUTINE initTree(this,name,val,description)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  TYPE(ParamType),INTENT(IN),OPTIONAL :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description

  IF(.NOT.ALLOCATED(this%val)) THEN
    CALL this%initBase(name,description)
    this%dataType = PL_DATA_TYPE_TREE
    ALLOCATE(ParamType :: this%val)
  ENDIF
  IF(PRESENT(val)) THEN
    SELECTTYPE(ptr => this%val); TYPE IS(ParamType)
      ALLOCATE(ptr%root,SOURCE=val%root)
    ENDSELECT
  ENDIF

ENDSUBROUTINE initTree
!
!-------------------------------------------------------------------------------
!> @brief Initialize a @c ParamNode to contain a @c ParamType using a pointer
!> @param this the node to initialize
!> @param name the name of the node
!> @param val the @c paramType to use; optional, only allocated @c val if not present
!> @param description the node's description; optional, defaults to empty string
!>
SUBROUTINE initTree_pointer(this,name,val,description)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  TYPE(ParamType),POINTER,INTENT(IN),OPTIONAL :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description

  IF(.NOT.ALLOCATED(this%val)) THEN
    CALL this%initBase(name,description)
    this%dataType = PL_DATA_TYPE_TREE
    ALLOCATE(ParamType :: this%val)
  ENDIF
  IF(PRESENT(val)) THEN
    SELECTTYPE(ptr => this%val); TYPE IS(ParamType)
      ptr%root => val%root
    ENDSELECT
  ENDIF

ENDSUBROUTINE initTree_pointer
!
!-------------------------------------------------------------------------------
!> @brief Renames a @c paramNode
!> @param this the node to rename
!> @param name the new name of the node
!> @param description the new description of the node; optional, defaults to empty string
!>
!> Also sets the hash of the node name for searching
!>
SUBROUTINE renameParam(this,name,description)
  CLASS(ParamNode),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: name
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description

  IF(PRESENT(name)) THEN
    this%name = TRIM(ADJUSTL(name))
    this%uppernameHash = stringHash(TRIM(ADJUSTL(this%name%upper())),PL_HASH_POLYNOMIAL_BASE,PL_HASH_MODULUS)
  ENDIF
  IF(PRESENT(description)) this%description=description

ENDSUBROUTINE renameParam
!
!-------------------------------------------------------------------------------
!> @brief Clears all data on a @c ParamNode
!> @param this the node to clear
!> @param clearLeafs controls where to clear @c left and @c right; optional, defaults
!>        to @c .FALSE.
!>
RECURSIVE SUBROUTINE clearNode(this,clearLeafs)
  CLASS(ParamNode),INTENT(INOUT) :: this
  LOGICAL(SBK),INTENT(IN) :: clearLeafs

  this%name=''
  this%upperNameHash=0_SIK
  this%dataType=PL_DATA_TYPE_NULL
  this%description=''
  IF(ALLOCATED(this%val)) THEN
    CALL this%val%clear()
    DEALLOCATE(this%val)
  ENDIF
  !Clear recursively
  IF(clearLeafs) THEN
    IF(ASSOCIATED(this%left)) THEN
      CALL this%left%clearNode(clearLeafs)
      DEALLOCATE(this%left)
    ENDIF
    IF(ASSOCIATED(this%right)) THEN
      CALL this%right%clearNode(clearLeafs)
      DEALLOCATE(this%right)
    ENDIF
  ENDIF
  this%left => NULL()
  this%right => NULL()
  this%parent => NULL()

ENDSUBROUTINE clearNode
!
!-------------------------------------------------------------------------------
!> @brief Edits a @c ParamNode to a text file
!> @param this the @c ParamNode to edit
!> @param funit the file unit number
!> @param indent the number of indentations preceding the parameter
!> @param prefix optional prefix to add before the datatype
!> @param paddtw optional whitespace padding to add before the datatype
!>
RECURSIVE SUBROUTINE editNodeToText(this,funit,indent,prefix,paddtw)
  CLASS(ParamNode),INTENT(IN) :: this
  INTEGER(SIK),INTENT(IN) :: funit
  INTEGER(SIK),INTENT(IN),OPTIONAL :: indent
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: prefix
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: paddtw
  !
  INTEGER(SIK) :: i
  TYPE(StringType) :: sprefix,sdtype

  !Write the left node first
  IF(ASSOCIATED(this%left)) THEN
    CALL this%left%editNodeToText(funit,indent,prefix,paddtw)
  ENDIF
  !Write this node
  IF(ALLOCATED(this%val)) THEN
    IF(PRESENT(prefix)) sprefix = prefix
    sdtype = paramTypeNames(this%dataType)
    IF(PRESENT(paddtw)) THEN
      IF(paddtw) THEN
        sdtype = REPEAT(' ',26-LEN(sdtype))
      ENDIF
    ENDIF
    i=1
    IF(PRESENT(indent)) i = i + indent
    WRITE(UNIT=funit,FMT='('//str(i)//'x,a)',ADVANCE='NO') sprefix//sdtype//' :: '//this%name//'='
    CALL this%val%editToText(funit,i,sprefix,LEN(sprefix)+LEN(sdtype)+LEN(this%name)+5,CHAR(this%description),paddtw)
  ENDIF
  !Write the right node last
  IF(ASSOCIATED(this%right)) THEN
    CALL this%right%editNodeToText(funit,indent,prefix,paddtw)
  ENDIF

ENDSUBROUTINE editNodeToText
!
!-------------------------------------------------------------------------------
!> @brief Edit a @c ParamNode to an HDF5 file
!> @param this the @c ParamNode to edit
!> @param file the @c HDF5FileType object to write to
!> @param path the location in @c file to write
!>
SUBROUTINE editNodeToH5(this,file,path)
  CLASS(ParamNode),INTENT(IN) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path

  IF(ALLOCATED(this%val)) THEN
    CALL this%val%editToH5(file,path)
    IF(LEN_TRIM(this%description) > 0) THEN
      CALL file%write_attribute(path,'description',this%description)
    ENDIF
  ENDIF

ENDSUBROUTINE editNodeToH5
!
!===============================================================================
! Methods for the ParamTypeIterator
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Activates the iterator from a @c ParamType
!> @param this the iterator to activate
!> @param tree the @c ParamType to iterate over
!> @param sublists whether to iterate over lower levels of the tree; optional, defaults to @c .FALSE.
!>
RECURSIVE SUBROUTINE activate(this,tree,sublists)
  CLASS(ParamTypeIterator),INTENT(INOUT) :: this
  CLASS(ParamType),TARGET,INTENT(IN) :: tree
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: sublists
  !
  CLASS(ParamNode),POINTER :: node

  CALL getLeftmostNode(tree%root,node)

  IF(ASSOCIATED(node)) THEN
    this%name = node%name
    this%dataType = node%dataType
    this%node => node
    this%tree => tree
    this%isActive = .TRUE.
    this%iterateSubLists = .FALSE.
    IF(PRESENT(sublists)) this%iterateSubLists = sublists
    SELECTTYPE(p => this%node%val); CLASS IS(ParamType)
      IF(ASSOCIATED(p%root) .AND. this%iterateSubLists) THEN
        ALLOCATE(this%subIter)
        CALL this%subIter%activate(p,SUBLISTS=.TRUE.)
      ENDIF
    ENDSELECT
  ELSE
    CALL this%clear()
  ENDIF

ENDSUBROUTINE activate
!
!-------------------------------------------------------------------------------
!> @brief Advances an iterator to the next node
!> @param this the iterator to advance
!>
!> Recursively calls sub-iterators if needed
!>
RECURSIVE SUBROUTINE advance(this)
  CLASS(ParamTypeIterator),INTENT(INOUT) :: this

  IF(this%isActive) THEN
    SELECTTYPE(p => this%node%val)
    CLASS IS(ParamType)
      IF(ASSOCIATED(this%subIter)) THEN
        CALL this%subIter%advance()
        IF(.NOT.this%subIter%isActive) THEN
          DEALLOCATE(this%subIter)
          CALL this%getNextNode(this%tree,this%node)
        ENDIF
      ELSEIF(ASSOCIATED(p%root) .AND. this%iterateSubLists) THEN
        ALLOCATE(this%subIter)
        CALL this%subIter%activate(p,SUBLISTS=.TRUE.)
      ELSE
        CALL this%getNextNode(this%tree,this%node)
      ENDIF
    CLASS DEFAULT
      CALL this%getNextNode(this%tree,this%node)
    ENDSELECT
    IF(ASSOCIATED(this%node)) THEN
      this%name = TRIM(ADJUSTL(this%node%name))
      this%dataType = this%node%dataType
    ELSE
      CALL this%clear()
    ENDIF
  ENDIF

ENDSUBROUTINE advance
!
!-------------------------------------------------------------------------------
!> @brief Retrieves the name of the current node during iteration
!> @param this the iterator
!> @param fullPath indicates where to include parent iterators; optional, default to @c .TRUE.
!> @returns name the name of the node
!>
!> If the iterator was initialized through @c ParamType%get(path,iterator), then
!> the @c name is relative to the end of @c path.  Even if @c fullPath is @c .TRUE.,
!> @c path will not be contained in @c name.  Only the names of individual sub-iterators
!> will be included in @c name.
!>
RECURSIVE FUNCTION getCurrentName(this,fullPath) RESULT(name)
  CLASS(ParamTypeIterator),INTENT(IN) :: this
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: fullPath
  TYPE(StringType) :: name
  !
  LOGICAL(SBK) :: full

  full = .TRUE.
  IF(PRESENT(fullPath)) full = fullPath

  IF(ASSOCIATED(this%subIter)) THEN
    name = this%subIter%getCurrentName(fullPath)
    IF(full) THEN
      name = this%name//'->'//name
    ENDIF
  ELSE
    name = this%name
  ENDIF

ENDFUNCTION getCurrentName
!
!-------------------------------------------------------------------------------
!> @brief Retrieves the data type for the current node during iteration
!> @param this the iterator to query
!> @returns dataType the data type of the node
!>
RECURSIVE FUNCTION getCurrentType(this) RESULT(dataType)
  CLASS(ParamTypeIterator),INTENT(IN) :: this
  INTEGER(SIK) :: dataType

  IF(ASSOCIATED(this%subIter)) THEN
    dataType = this%subIter%getCurrentType()
  ELSE
    dataType = this%dataType
  ENDIF

ENDFUNCTION getCurrentType
!
!-------------------------------------------------------------------------------
!> @brief Retrives a pointer to the current node during iteration
!> @param this the iterator to query
!> @returns node the pointer to the current node
!>
!> This routine is not recommended for use by the client since it is possible to
!> corrupt the tree if not careful.  However, the method is exposed as it may
!> be useful for memory saving or other purposes and is the only way to truly
!> retrive a pointer to a sub-tree.
!>
RECURSIVE FUNCTION getCurrentNode(this) RESULT(node)
  CLASS(ParamTypeIterator),INTENT(IN) :: this
  CLASS(ParamNode),POINTER :: node

  IF(ASSOCIATED(this%subIter)) THEN
    node => this%subIter%getCurrentNode()
  ELSE
    node => this%node
  ENDIF

ENDFUNCTION getCurrentNode
!
!-------------------------------------------------------------------------------
!> @brief Clear the iterator
!> @param this the iterator to clear
RECURSIVE SUBROUTINE clearIterator(this)
  CLASS(ParamTypeIterator),INTENT(INOUT) :: this

  this%name = ''
  this%dataType = PL_DATA_TYPE_NULL
  this%node => NULL()
  this%tree => NULL()
  this%iterateSubLists = .TRUE.
  this%isActive = .FALSE.
  IF(ASSOCIATED(this%subIter)) THEN
    CALL this%subIter%clear()
    DEALLOCATE(this%subIter)
  ENDIF

ENDSUBROUTINE clearIterator
!
!-------------------------------------------------------------------------------
!> @brief Retrieves the next node in a tree according to hash value
!> @param this the @c ParamType being iterated on
!> @param node the next node identified in the tree
!>
RECURSIVE SUBROUTINE getNextNode(this,node)
  CLASS(ParamType),INTENT(IN) :: this
  CLASS(ParamNode),POINTER,INTENT(INOUT) :: node
  !
  CLASS(ParamNode),POINTER :: previousNode

  IF(.NOT.ASSOCIATED(node)) RETURN

  !Now we implement the successor algorithm: https://stackoverflow.com/questions/2942517/how-do-i-iterate-over-binary-tree
  previousNode => node
  !If the node has a right child, the leftmost leaf of that subtree is the next node
  CALL getLeftmostNode(node%right,node)
  !If there is no right leaf, then the first parent node to the right of the current node
  !is the next node
  IF(.NOT.ASSOCIATED(node)) THEN
    node => previousNode
    DO WHILE(ASSOCIATED(node))
      IF(node%upperNameHash > previousNode%upperNameHash) THEN
        EXIT
      ELSE
        previousNode => node
        node => node%parent
      ENDIF
    ENDDO
  ENDIF

ENDSUBROUTINE getNextNode
!
!-------------------------------------------------------------------------------
!> @brief Edits an iterator's current node to an HDF5 file
!> @param this the iterator to edit
!> @param file the @c HDF5FileType to write to
!> @param path the location of the file to write to
!>
SUBROUTINE editIteratorToH5(this,file,path)
  CLASS(ParamTypeIterator),INTENT(IN) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path

  REQUIRE(this%isActive)

  CALL this%node%edit(file,path)

ENDSUBROUTINE editIteratorToH5
!
!===============================================================================
! Methods for tree (ParamType)
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Clears a @c ParamType object
!> @param this the object to clear
!>
RECURSIVE SUBROUTINE clearTree(this)
  CLASS(ParamType),INTENT(INOUT) :: this

  IF(ASSOCIATED(this%root)) THEN
    CALL this%root%clearNode(.TRUE.)
    DEALLOCATE(this%root)
  ENDIF

ENDSUBROUTINE clearTree
!
!-------------------------------------------------------------------------------
!> @brief Determines whether a node exists in a tree
!> @param this the @c ParamType to query
!> @param name the node to search for
!> @returns the result of the search
!>
FUNCTION has(this,name) RESULT(bool)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  LOGICAL(SBK) :: bool
  !
  CLASS(ParamNode),POINTER :: node

  CALL this%getNode_Name(name,node)
  bool = ASSOCIATED(node)

ENDFUNCTION has
!
!-------------------------------------------------------------------------------
!> @brief Removes a node if it exists exists in a tree
!> @param this the @c ParamType to query
!> @param name the node to search for
!>
!> Must use the whole path to remove nodes.  If the levels above the bottom-most
!> node are empty after removal, those levels will also be removed.
!>
RECURSIVE SUBROUTINE remove(this,name)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  !
  LOGICAL(SBK) :: deleteNode
  INTEGER(SLK),ALLOCATABLE :: hashes(:)
  CLASS(ParamNode),POINTER :: removedNode

  !Identify the node to be removed and hashes for any lower levels
  CALL get_hash_list(name,hashes)
  CALL getNode_Hashes(this,hashes(1:1),removedNode,.TRUE.)
  !If we couldn't find the node then just immediately return
  IF(.NOT.ASSOCIATED(removedNode)) RETURN

  !If there are more elements to the path, then search the next level down
  deleteNode = (SIZE(hashes) == 1)
  IF(SIZE(hashes) > 1) THEN
    SELECTTYPE(param => removedNode%val); TYPE IS(ParamType)
      CALL param%remove(name(INDEX(name,'->')+2:))
    ENDSELECT
  ENDIF

  !If a node was not removed from a lower level, then remove it here
  IF(deleteNode) THEN
    CALL removeNode(this%root,hashes(1))
  ENDIF

ENDSUBROUTINE remove
!
!-------------------------------------------------------------------------------
!> @brief Returns the name of the @c root of a @c ParamType
!> @param this the @c ParamType to query
!> @returns name the name of the @c root
!>
!> This can be useful if the client knows there is only one node in the top level
!> of a @c ParamType, which is a common use case.  However, if multiple nodes are
!> in the top level, an iterator is likely needed instead of this funciton.
!>
FUNCTION getName(this) RESULT(name)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=:),ALLOCATABLE :: name

  IF(ASSOCIATED(this%root)) THEN
    name = TRIM(ADJUSTL(this%root%name))
  ELSE
    name = ''
  ENDIF

ENDFUNCTION getName
!
!-------------------------------------------------------------------------------
!> @brief Gets the hash of a node in a tree
!> @param this the @c ParamType to query
!> @param name the name of the node to search for
!> @returns nameHash the hash of the name of the node
!>
!> This function has a niche use case that could be important for optimized use
!> of this module.  Since the hashing parameters are module private, a client
!> may want to compare the hashes of parameter list paths without having to identify
!> the hashing parameters themselves.
!>
FUNCTION getNameHash(this,name) RESULT(nameHash)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SLK) :: nameHash
  !
  CHARACTER(LEN=*),PARAMETER :: myname='getNameHash'
  CLASS(ParamNode),POINTER :: node

  CALL this%getNode_Name(name,node)
  IF(ASSOCIATED(node)) THEN
    nameHash = node%uppernameHash
  ELSE
    CALL eParams%raiseError(modName//'::'//myName// &
        ' - could not retrieve hash for parameter "'//name//'"!')
  ENDIF

ENDFUNCTION getNameHash
!
!-------------------------------------------------------------------------------
!> @brief Gets the description of a node in a tree
!> @param this the @c ParamType to query
!> @param name the name of the node to search for
!> @returns description the description of the node
!>
FUNCTION getDescription(this,name) RESULT(description)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=:),ALLOCATABLE :: description
  !
  CLASS(ParamNode),POINTER :: node

  CALL this%getNode_Name(name,node)
  IF(ASSOCIATED(node)) THEN
    description = TRIM(ADJUSTL(node%description))
  ELSE
    description = ''
  ENDIF

ENDFUNCTION getDescription
!
!-------------------------------------------------------------------------------
!> @brief Gets the data type of a node in a tree
!> @param this the @c ParamType to query
!> @param name the name of the node to search for
!> @returns dataType the dataType of the node
!>
FUNCTION getDataType(this,name) RESULT(dataType)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  INTEGER(SIK) :: dataType
  !
  CLASS(ParamNode),POINTER :: node

  CALL this%getNode_Name(name,node)
  dataType = PL_DATA_TYPE_NULL
  IF(ASSOCIATED(node)) THEN
    dataType = node%dataType
  ENDIF

ENDFUNCTION getDataType
!
!-------------------------------------------------------------------------------
!> @brief Copies parameters from one @c ParamType to another
!> @param source the source @c paramType
!> @param source_path the path of the parameters to copy
!> @param dest_path the destination of the parameters
!> @param dest the target @c ParamType to copy to
!> @param overwrite whether to overwrite pre-existing parameters; optional, defaults to @c .FALSE.
!>
RECURSIVE SUBROUTINE copyParam(source,source_path,dest_path,dest,overwrite)
  CLASS(ParamType),INTENT(IN) :: source
  CHARACTER(LEN=*),INTENT(IN) :: source_path
  CHARACTER(LEN=*),INTENT(IN) :: dest_path
  CLASS(ParamType),INTENT(INOUT) :: dest
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: overwrite
  !
  CHARACTER(LEN=*),PARAMETER :: myName='copyParam'
  LOGICAL(SBK) :: loverwrite
  CLASS(ParamNode),POINTER :: source_node,dest_node
  TYPE(ParamTypeIterator) :: iterator

  loverwrite = .FALSE.
  IF(PRESENT(overwrite)) loverwrite = overwrite

  CALL source%getNode_name(source_path,source_node)
  IF(ASSOCIATED(source_node)) THEN
    IF(dest%has(dest_path) .AND. .NOT.loverwrite) THEN
      CALL eParams%raiseError(modName//'::'//myName//' - Cannot overwrite dataset "'// &
          dest_path//'" with source parameter "'//source_path//'"!')
    ELSE
      IF(source_node%dataType == PL_DATA_TYPE_TREE) THEN
        CALL source%get(source_path,iterator,SUBLISTS=.TRUE.)
        DO WHILE(iterator%isActive)
          CALL source%copyParam(source_path//'->'//CHAR(iterator%getCurrentName()), &
              dest_path//'->'//iterator%getCurrentName(.TRUE.),dest,loverwrite)
          CALL iterator%advance()
        ENDDO
        CALL dest%getNode_Name(dest_path,dest_node)
      ELSE
        CALL dest%getOrCreateNode_Name(dest_path,dest_node,.TRUE.)
        IF(ALLOCATED(dest_node%val)) THEN
          CALL dest_node%val%clear()
          DEALLOCATE(dest_node%val)
        ENDIF
        dest_node%val = source_node%val
      ENDIF
      CALL assign_ParamNodeMetadta(dest_node,source_node)
    ENDIF
  ENDIF

ENDSUBROUTINE copyParam
!
!-------------------------------------------------------------------------------
!> @brief Initilize a parameter list from an XML file
!> @param this the parameter list to be populated from the XML file
!> @param fname the name of the input XML file
!> @param fmuXML_opt a flag to denote that the XML file is a Functional
!>        Mockup Unit (FMU) model description
!>
SUBROUTINE initFromXML(this, fname, fmuXML_opt)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: fname
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: fmuXML_opt
  !
  LOGICAL(SBK) :: fmuXML
  INTEGER(SIK) :: i
  TYPE(StringType) :: tmpStr,nameVal
  TYPE(XMLFileType) :: xmlFile
  TYPE(XMLElementType),POINTER :: iXMLE
  TYPE(StringType) :: currentPath

  IF(.NOT. PRESENT(fmuXML_opt)) THEN
    fmuXML=.FALSE.
  ELSE
    fmuXML=fmuXML_opt
  ENDIF

  IF(.NOT.ASSOCIATED(this%root)) THEN
    !Initialize the XML file
    CALL xmlfile%importFromDisk(fname)
    DO i = 1,SIZE(xmlfile%root)
      iXMLE => xmlfile%root(i)
      tmpStr='name'
      CALL iXMLE%getAttributeValue(tmpStr,nameVal)
      currentPath=nameVal
      IF(fmuXML) THEN
        CALL procFMUXMLTree(this,iXMLE,currentPath)
      ELSE
        CALL procXMLTree(this,iXMLE,currentPath)
      ENDIF
    ENDDO !i
    CALL xmlfile%clear()
  ENDIF

ENDSUBROUTINE initFromXML
!
!-------------------------------------------------------------------------------
!> @brief Processes an XML tree
!> @param this the parameter list to store the XML in
!> @param parent the parent XML element
!> @param currentPath the path of the current XML element
!>
RECURSIVE SUBROUTINE procXMLTree(this,parent,currentPath)
  CLASS(ParamType),INTENT(INOUT) :: this
  TYPE(XMLElementType),POINTER,INTENT(IN) :: parent
  TYPE(StringType),INTENT(IN) :: currentPath
  !
  LOGICAL(SBK) :: boolVal
  INTEGER(SIK) :: ic,intVal
  INTEGER(SIK),ALLOCATABLE :: intArry(:)
  REAL(SSK) :: singleVal
  REAL(SDK) :: doubleVal
  REAL(SDK),ALLOCATABLE :: doubleArry(:)
  TYPE(StringType) :: elname,tmpStr,typval,attrVal,nameVal,tmpPath
  TYPE(StringType),ALLOCATABLE :: strArry(:)
  TYPE(XMLElementType),POINTER :: iXMLE,children(:)
  CLASS(ParamNode),POINTER :: node

  CALL parent%getChildren(children)
  !Check to see if it's an empty parameter list
  IF(.NOT.ASSOCIATED(children)) THEN
    CALL this%getOrCreateNode_Name(CHAR(currentPath),node,.TRUE.)
    CALL node%initTree(CHAR(node%name))
    RETURN
  ENDIF

  DO ic=1,SIZE(children)
    tmpPath=currentPath//' -> '
    iXMLE => children(ic)

    elname=iXMLE%name%upper()
    IF(elname == 'PARAMETER') THEN
      tmpStr='type'
      CALL iXMLE%getAttributeValue(tmpStr,typval)
      typval = typval%upper()
      tmpStr='value'
      CALL iXMLE%getAttributeValue(tmpStr,attrVal)
      tmpStr='name'
      CALL iXMLE%getAttributeValue(tmpStr,nameVal)
      tmpPath=tmpPath//nameVal
      SELECTCASE(CHAR(typval))
      CASE('BOOL')
        boolVal=CHAR(attrVal)
        CALL this%add(CHAR(tmpPath),boolVal)
      CASE('INT')
        intVal=CHAR(attrVal)
        CALL this%add(CHAR(tmpPath),intVal)
      CASE('FLOAT')
        singleVal=CHAR(attrVal)
        CALL this%add(CHAR(tmpPath),singleVal,'XML_IN_VAL='//attrval)
      CASE('DOUBLE')
        doubleVal=CHAR(attrVal)
        CALL this%add(CHAR(tmpPath),doubleVal,'XML_IN_VAL='//attrval)
      CASE('STRING')
        CALL this%add(CHAR(tmpPath),attrVal)
      CASE('ARRAY(INT)')
        tmpStr = attrVal%substr(2,LEN(attrVal)-1) !Get everything except the braces
        strArry = tmpStr%split(',')
        intArry = strArry%stoi()
        CALL this%add(CHAR(tmpPath),INT(intArry,SIK))
      CASE('ARRAY(DOUBLE)')
        tmpStr = attrVal%substr(2,LEN(attrVal)-1) !Get everything except the braces
        strArry = tmpStr%split(',')
        doubleArry = strArry%stof()
        CALL this%add(CHAR(tmpPath),doubleArry,'XML_IN_VAL='//attrval)
      CASE('ARRAY(STRING)')
        tmpStr = attrVal%substr(2,LEN(attrVal)-1) !Get everything except the braces
        strArry = tmpStr%split(',')
        CALL this%add(CHAR(tmpPath),strArry)
        strArry=''
      CASE DEFAULT
        !Bad element type
      ENDSELECT
    ELSE IF(elname == 'PARAMETERLIST') THEN
      !Add to list (without arrow)
      tmpStr='name'
      CALL iXMLE%getAttributeValue(tmpStr,nameVal)
      tmpPath=tmpPath//nameVal
      CALL procXMLTree(this,iXMLE,tmpPath)
    ENDIF
  ENDDO

ENDSUBROUTINE procXMLTree
!
!-------------------------------------------------------------------------------
!> @brief Processes an FMU XML tree
!> @param this the parameter list to store the XML in
!> @param parent the parent XML element
!> @param currentPath the path of the current XML element
!>
RECURSIVE SUBROUTINE procFMUXMLTree(this,parent,currentPath)
  CLASS(ParamType),INTENT(INOUT) :: this
  TYPE(StringType),INTENT(IN) :: currentPath
  TYPE(XMLElementType),POINTER :: parent
  !
  TYPE(XMLElementType),POINTER :: iXMLE,children(:),dChildren(:)
  TYPE(ParamType),POINTER :: pList(:)
  TYPE(StringType) :: elname,tmpPath,tmpNewPath
  INTEGER(SIK) :: ic,ia,ib
  TYPE(StringType),ALLOCATABLE :: tmpKeys(:)
  TYPE(StringType),ALLOCATABLE :: tmpValues(:)
  TYPE(StringType) :: tmpKey, tmpVal, tmpPathToTmpVar
  CLASS(ParamNode),POINTER :: node

  NULLIFY(pList)
  CALL parent%getChildren(children)
  !Check to see if it's an empty parameter list
  IF(.NOT.ASSOCIATED(children)) THEN
    CALL this%getOrCreateNode_Name(CHAR(currentPath),node,.TRUE.)
    RETURN
  ENDIF

  DO ic=1,SIZE(children)
    tmpPath=currentPath//' -> '
    iXMLE => children(ic)
    elname=iXMLE%name%upper()
    tmpNewPath = tmpPath // elname
    IF(elname == 'SCALARVARIABLE') THEN
      CALL iXMLE%getAttributes(tmpKeys, tmpValues)
      DO ia=1,SIZE(tmpKeys)
        tmpKey = tmpKeys(ia)
        tmpVal = tmpValues(ia)
        IF(tmpKey=='name') THEN
          DO ib=1,SIZE(tmpKeys)
            IF(tmpKeys(ib)=='valueReference') THEN
              tmpPathToTmpVar = 'FMU'//currentPath//' -> '//tmpVal//' -> valueReference'
              IF(this%has(CHAR(tmpPathToTmpVar))) THEN
                CALL eParams%raiseWarning(modName//" - Duplicate FMU Variable: "//CHAR(tmpPathToTmpVar))
                CALL this%set(CHAR(tmpPathToTmpVar),tmpValues(ib))
              ELSE
                CALL this%add(CHAR(tmpPathToTmpVar),tmpValues(ib))
              ENDIF
            ELSE IF(tmpKeys(ib)=='causality') THEN
              tmpPathToTmpVar = 'FMU'//currentPath//' -> '//tmpVal//' -> causality'
              CALL this%add(CHAR(tmpPathToTmpVar),tmpValues(ib))
            ENDIF
          ENDDO
        ENDIF
      ENDDO
      DEALLOCATE(tmpKeys)
      DEALLOCATE(tmpValues)
    ELSE IF(elname == 'DEFAULTEXPERIMENT') THEN
      CALL iXMLE%getAttributes(tmpKeys, tmpValues)
      DO ia=1,SIZE(tmpKeys)
        tmpPathToTmpVar = elname//currentPath//' -> '//tmpKeys(ia)
        CALL this%add(CHAR(tmpPathToTmpVar),tmpValues(ia))
      ENDDO
    ELSE IF(elname == 'COSIMULATION') THEN
      CALL iXMLE%getAttributes(tmpKeys, tmpValues)
      DO ia=1,SIZE(tmpKeys)
        tmpPathToTmpVar = elname//currentPath//' -> '//tmpKeys(ia)
        CALL this%add(CHAR(tmpPathToTmpVar),tmpValues(ia))
      ENDDO
    ELSE IF(elname == 'MODELVARIABLES') THEN
      CALL procFMUXMLTree(this,iXMLE,tmpNewPath)
    ELSE IF(elname == 'MODELSTRUCTURE') THEN
      CALL iXMLE%getChildren(dChildren)
      ! Check for empty parameterlist
      IF(ASSOCIATED(dChildren)) THEN
        CALL procFMUXMLTree(this,iXMLE,tmpNewPath)
      ENDIF
    ELSE IF(elname == 'DERIVATIVES') THEN
      ! Count number of children
      CALL iXMLE%getChildren(dChildren)
      IF(ASSOCIATED(dChildren)) THEN
        tmpPathToTmpVar = 'FMU'//currentPath//' -> nDerivatives'
        CALL this%add(CHAR(tmpPathToTmpVar),SIZE(dChildren))
      ENDIF
    ENDIF
  ENDDO

  IF(parent%name%upper() == 'FMIMODELDESCRIPTION') THEN
    tmpKey='guid'
    CALL parent%getAttributeValue(tmpKey,tmpVal)
    CALL this%add(CHAR(tmpKey),tmpVal)
  ENDIF

ENDSUBROUTINE procFMUXMLTree
!
!-------------------------------------------------------------------------------
!> @brief Condenses a parameters data into a @c StringType
!> @param this the parameter whose data should be string-ified
!> @param path the path of the parameter; applicable only if @c this is a @c ParamType
!> @param string the resulting string containing the data
!> @param sskfmt the single-precision real format; optional, defaults to @c '(es14.6)'
!> @param sdkfmt the double-precision real format; optional, defaults to @c '(es23.16)'
RECURSIVE SUBROUTINE getString(this,path,string,sskfmt,sdkfmt)
  CLASS(Param_Base),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: path
  TYPE(StringType),INTENT(OUT) :: string
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: sskfmt
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: sdkfmt
  !
  INTEGER(SIK) :: i,j,k
  CHARACTER(LEN=16) :: sskfmtDef,sdkfmtDef
  CHARACTER(LEN=128) :: tmpchar
  TYPE(StringType) :: delim
  CLASS(ParamNode),POINTER :: node

  IF(PRESENT(sskfmt)) THEN
    sskfmtDef=sskfmt
  ELSE
    sskfmtDef='(es14.6)'
  ENDIF
  IF(PRESENT(sdkfmt)) THEN
    sdkfmtDef=sdkfmt
  ELSE
    sdkfmtDef='(es23.15)'
  ENDIF

  delim='"'
  string = ''
  SELECTTYPE(p => this)
  TYPE IS(Param_SBK0)
    WRITE(tmpchar,'(l1)') p%p
    string = TRIM(ADJUSTL(tmpchar))
  TYPE IS(Param_SNK0)
    string = str(p%p)
  TYPE IS(Param_SLK0)
    string = str(p%p)
  TYPE IS(Param_SSK0)
    WRITE(tmpchar,TRIM(sskfmtDef)) p%p
    string = TRIM(ADJUSTL(tmpchar))
  TYPE IS(Param_SDK0)
    WRITE(tmpchar,TRIM(sdkfmtDef)) p%p
    string = TRIM(ADJUSTL(tmpchar))
  TYPE IS(Param_Str0)
    string = p%p
  TYPE IS(Param_SBK1)
    IF(SIZE(p%p) > 0) THEN
      WRITE(tmpchar,'(l1)') p%p(1)
      string = delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      WRITE(tmpchar,'(l1)') p%p(i)
      string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ENDDO !i
  TYPE IS(Param_SNK1)
    IF(SIZE(p%p) > 0) THEN
      string = delim//str(p%p(1))//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      string = string//delim//str(p%p(i))//delim//' '
    ENDDO !i
  TYPE IS(Param_SLK1)
    IF(SIZE(p%p) > 0) THEN
      string = delim//str(p%p(1))//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      string = string//delim//str(p%p(i))//delim//' '
    ENDDO !i
  TYPE IS(Param_SSK1)
    IF(SIZE(p%p) > 0) THEN
      WRITE(tmpchar,TRIM(sskfmtDef)) p%p(1)
      string = delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      WRITE(tmpchar,TRIM(sskfmtDef)) p%p(i)
      string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ENDDO !i
  TYPE IS(Param_SDK1)
    IF(SIZE(p%p) > 0) THEN
      WRITE(tmpchar,TRIM(sdkfmtDef)) p%p(1)
      string = delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      WRITE(tmpchar,TRIM(sdkfmtDef)) p%p(i)
      string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
    ENDDO !i
  TYPE IS(Param_Str1)
    IF(SIZE(p%p) > 0) THEN
      string = delim//p%p(1)//delim//' '
    ELSE
      string = delim//' '
    ENDIF
    DO i = 2,SIZE(p%p)
      string = string//delim//p%p(i)//delim//' '
    ENDDO !i
  TYPE IS(Param_SBK2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        WRITE(tmpchar,'(l1)') p%p(i,j)
        string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_SNK2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        string = string//delim//str(p%p(i,j))//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_SLK2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        string = string//delim//str(p%p(i,j))//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_SSK2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        WRITE(tmpchar,sskfmtDef) p%p(i,j)
        string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_SDK2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        WRITE(tmpchar,sdkfmtDef) p%p(i,j)
        string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_Str2)
    string = ''
    DO j = 1,SIZE(p%p,DIM=2)
      DO i = 1,SIZE(p%p,DIM=1)
        string = string//delim//p%p(i,j)//delim//' '
      ENDDO !i
    ENDDO !j
  TYPE IS(Param_SBK3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          WRITE(tmpchar,'(l1)') p%p(i,j,k)
          string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(Param_SNK3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          string = string//delim//str(p%p(i,j,k))//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(Param_SLK3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          string = string//delim//str(p%p(i,j,k))//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(Param_SSK3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          WRITE(tmpchar,sskfmtDef)
          string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(Param_SDK3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          WRITE(tmpchar,sdkfmtDef)
          string = string//delim//TRIM(ADJUSTL(tmpchar))//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(Param_Str3)
    string = ''
    DO k = 1,SIZE(p%p,DIM=3)
      DO j = 1,SIZE(p%p,DIM=2)
        DO i = 1,SIZE(p%p,DIM=1)
          string = string//delim//p%p(i,j,k)//delim//' '
        ENDDO !i
      ENDDO !j
    ENDDO !k
  TYPE IS(ParamType)
    CALL p%getNode_name(path,node)
    IF(ASSOCIATED(node)) THEN
      CALL node%val%getString(path,string,sskfmt,sdkfmt)
    ENDIF
  ENDSELECT

ENDSUBROUTINE getString
!
!-------------------------------------------------------------------------------
!> @brief Converts a @c ParamType to a 2D array of @c StringType objects
!> @param this the @c ParamType to convert
!> @param baseAddr the address in @c this to convert to a 2D array
!> @param tablevals the resulting array of strings
!>
!> The parameter should be structured as follows:
!> @code
!>                  Path
!> =======================================================
!>    baseAddr -> 1 -> 1               a
!>                  -> 2               b
!>                  -> 3               c
!>                  -> 4               d
!>             -> 2 -> 1               e
!>                  -> 2               f
!>                  -> 3               g
!>                  -> 4               h
!>             -> 3 -> 1               i
!>                  -> 2               j
!>                  -> 3               k
!>                  -> 4               l
!>             -> 4 -> 1               m
!>                  -> 2               n
!>                  -> 3               o
!>                  -> 4               p
!> @endcode
!> The resulting values of @c tableVals(i,j) will be:
!> @code
!>    j | 1 | 2 | 3 | 4 |
!>  i   |   |   |   |   |
!>  1   | a | e | i | m |
!>  2   | b | f | j | n |
!>  3   | c | g | k | o |
!>  4   | d | h | l | p |
!> @endcode
!>
SUBROUTINE convertTo2DStringArray(this,baseAddr,tablevals)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: baseAddr
  TYPE(Stringtype),ALLOCATABLE,INTENT(OUT) :: tablevals(:,:)
  !
  INTEGER(SIK) :: i,j,ncol,nrow
  TYPE(StringType) :: addr,plstr
  TYPE(ParamTypeIterator) :: iterator

  !Initialize data
  !Loop over all columns, get the number of columns for the table
  ncol = 0
  nrow = 0
  addr = baseAddr
  CALL this%getIterator(CHAR(addr),iterator,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    ncol = ncol+1
    CALL iterator%advance()
  ENDDO

  CALL this%get(baseAddr//'->1',iterator,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    nrow = nrow + 1
    CALL iterator%advance()
  ENDDO

  IF((nrow > 0) .AND. (ncol > 0)) THEN
    !Allocate data
    ALLOCATE(tablevals(ncol,nrow))
    tablevals = '-'

    CALL this%get(baseAddr//'->1',iterator,SUBLISTS=.FALSE.)
    DO j = 1,nrow
      CALL this%getString(baseAddr//'->1->'//str(j),plstr)
      IF(LEN_TRIM(plstr) > 0) tablevals(1,j) = plstr
      CALL iterator%advance()
    ENDDO !j

    !Loop over all of the columns
    DO i = 2,ncol
      DO j = 1,nrow
        IF(this%has(baseAddr//'->'//str(i)//'->'//str(j))) THEN
          CALL this%getString(baseAddr//'->'//str(i)//'->'//str(j),plstr)
          IF(LEN_TRIM(plstr) > 0) tablevals(i,j) = plstr
        ENDIF
      ENDDO !j
    ENDDO !i
  ENDIF

ENDSUBROUTINE convertTo2DStringArray
!
!-------------------------------------------------------------------------------
#ifdef FUTILITY_HAVE_Trilinos
!> @brief Converts a Futility parameter list to a Teuchos parameter list
!> @param this the Futility parameter list to convert
!> @param that the target Teuchos parameter list to fill with @c this
!> @param n the starting level in @c that; optional, default to 0
!>
RECURSIVE SUBROUTINE toTeuchosPlist(this, that, n)
  CLASS(ParamType),INTENT(IN) :: this
  TYPE(ForTeuchos_ParameterList_ID),INTENT(IN) :: that
  INTEGER(SNK),INTENT(IN),OPTIONAL :: n
  !
  INTEGER(C_INT) :: ierr
  INTEGER(SNK) :: level
  TYPE(ForTeuchos_ParameterList_ID) :: new
  CLASS(ParamNode),POINTER :: node
  TYPE(ParamTypeIterator) :: iterator

  level = 0
  IF(PRESENT(n)) THEN
    level = n
  ENDIF

  CALL iterator%activate(this,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    node => iterator%getCurrentNode()
    SELECTTYPE(ptr => node%val)
    TYPE IS(ParamType)
      ! This node is its own parameter list
      new = ForTeuchos_PL_sublist(that, CHAR(node%name), 0, &
          "Imported from MPACT PList", ierr)
      CALL toTeuchosPlist(ptr, new, level+1)
    TYPE IS(Param_SBK0)
      CALL ForTeuchos_PL_set_bool(that, CHAR(node%name), ptr%p,&
          CHAR(node%description), ierr)
    TYPE IS(Param_SDK0)
      CALL ForTeuchos_PL_set_double(that, CHAR(node%name), ptr%p,&
          CHAR(node%description), ierr)
    TYPE IS(Param_SNK0)
      CALL ForTeuchos_PL_set_int(that, CHAR(node%name), ptr%p,&
          CHAR(node%description), ierr)
    TYPE IS(Param_STR0)
      CALL ForTeuchos_PL_set_string(that, CHAR(node%name), CHAR(ptr%p),&
          CHAR(node%description), ierr)
    CLASS DEFAULT
      CALL eParams%raiseError("Unsupported parameter type " &
          //paramTypeNames(node%datatype)//" for Teuchos conversion.")
    ENDSELECT
    CALL iterator%advance()
  ENDDO
ENDSUBROUTINE toTeuchosPlist
#endif
!
!-------------------------------------------------------------------------------
!> @brief Validates a @c ParamType against required and optional parameters
!> @param this the @c ParmaType to validate
!> @param reqParams the required parameters that must exist on @c this
!> @param optParams the optional parameters that do not need to exist on @c this
!> @param printExtras logical indicating whether extra parameters should be printed;
!>        capability not implemented
!> @param valid the result of the validation check; optional
!>
!> Any optional parameters not found on @c this are created by copying from
!> @c optParams.  Parameters in @c reqParams must be of the same location and
!> data type in @c this, but the values may be different; only structure matters.
!>
!> This routine is intended for validation of parameters during execution.  For
!> unit testing, @c verify should be used instead.
!>
SUBROUTINE validate(this,reqParams,optParams,printExtras,valid)
  CLASS(ParamType),INTENT(INOUT) :: this
  CLASS(ParamType),INTENT(IN) :: reqParams
  CLASS(ParamType),INTENT(IN),OPTIONAL :: optParams
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: printExtras
  LOGICAL(SBK),INTENT(OUT),OPTIONAL :: valid
  !
  CHARACTER(LEN=*),PARAMETER :: myName='validate'
  LOGICAL(SBK) :: isValid
  TYPE(StringType) :: name
  CLASS(ParamNode),POINTER :: testnode
  TYPE(ParamTypeIterator) :: iterator

  !Check required params first
  isValid = .TRUE.
  CALL iterator%activate(reqParams,SUBLISTS=.TRUE.)
  DO WHILE(iterator%isActive)
    name = iterator%getCurrentName()
    CALL this%getNode_name(CHAR(name),testnode)
    IF(.NOT.ASSOCIATED(testnode)) THEN
      CALL eParams%raiseError(modName//'::'//myName//' - Failed to locate required parameter "'//name//'"!')
      isValid = .FALSE.
    ELSEIF(testnode%dataType /= iterator%getCurrentType()) THEN
      CALL eParams%raiseError(modName//'::'//myName// &
          ' - Required parameter "'//name//'" has type "'//TRIM(paramTypeNames(testnode%dataType))// &
          '" and must be type "'//TRIM(paramTypeNames(iterator%getCurrentType()))//'"!')
      isValid = .FALSE.
    ENDIF
    CALL iterator%advance()
  ENDDO

  !If no errors, then check the optional parameters too
  IF(isValid .AND. PRESENT(optParams)) THEN
    CALL iterator%activate(optParams,SUBLISTS=.TRUE.)
    DO WHILE(iterator%isActive)
      name = iterator%getCurrentName()
      CALL this%getOrCreateNode_Name(CHAR(name),testnode,.TRUE.)
      IF(testnode%dataType /= iterator%getCurrentType()) THEN
        IF(testnode%dataType /= PL_DATA_TYPE_NULL) THEN
          CALL eParams%raiseWarning(modName//'::'//myName//' - Optional parameter "'//name// &
              '" has type "'//TRIM(paramTypeNames(testnode%dataType))//'" and should be type "'// &
              TRIM(paramTypeNames(iterator%getCurrentType()))//'"!  It is being overridden with default value.')
        ENDIF
        CALL copy_node_data(testnode, iterator%getCurrentNode())
      ENDIF
      CALL iterator%advance()
    ENDDO
  ENDIF

  IF(PRESENT(valid)) valid = isValid

ENDSUBROUTINE validate
!
!-------------------------------------------------------------------------------
!> @brief Verifies that 2 @c ParamType objects have the same structure and values
!> @param this the @c ParamType to check
!> @param refList the reference @c ParamType
!> @param assert indicates if @c ASSERT should be called; optional, defaults to @c .TRUE.
!> @param fuzzy tolerance for real comparisons; optional, defaults to exact equality
!> @param structure whether to check only structure instead of values; optional, defaults to @c .FALSE.
!> @return isValid the result of the verification check
!>
!> This routine is intended for unit testing, where the exact values of
!> parameter lists may need to be checked.
!>
FUNCTION verify(this,refList,assert,fuzzy,structure) RESULT(isValid)
  CLASS(ParamType),INTENT(IN) :: this
  CLASS(ParamType),INTENT(IN) :: refList
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: assert
  REAL(SDK),INTENT(IN),OPTIONAL :: fuzzy
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: structure
  LOGICAL(SBK) :: isValid
  !
  LOGICAL(SBK) :: lassert,lstructure

  lassert = .TRUE.
  IF(PRESENT(assert)) lassert = assert

  lstructure = .FALSE.
  IF(PRESENT(structure)) lstructure = structure

  isValid = verify_helper(this,refList,lassert,fuzzy,lstructure,'')

ENDFUNCTION verify
!
!-------------------------------------------------------------------------------
!> @brief Helper routine for @c verify to support recursive checking
!> @param this the @c ParamType to check
!> @param refList the reference @c ParamType
!> @param assert indicates if @c ASSERT should be called; optional, defaults to @c .TRUE.
!> @param fuzzy tolerance for real comparisons; optional, defaults to exact equality
!> @param structure whether to check only structure instead of values; optional, defaults to @c .FALSE.
!> @param prefix path to the current level being checked
!> @return isValid the result of the verification check
!>
RECURSIVE FUNCTION verify_helper(this,refList,assert,fuzzy,structure,prefix) RESULT(isValid)
  CLASS(ParamType),INTENT(IN) :: this
  CLASS(ParamType),INTENT(IN) :: refList
  LOGICAL(SBK),INTENT(IN) :: assert
  REAL(SDK),INTENT(IN),OPTIONAL :: fuzzy
  LOGICAL(SBK),INTENT(IN) :: structure
  CHARACTER(LEN=*),INTENT(IN) :: prefix
  LOGICAL(SBK) :: isValid
  !
  CHARACTER(LEN=*),PARAMETER :: myName='verify_helper'
  LOGICAL(SBK) :: localValid
  TYPE(stringType) :: message
  CLASS(ParamNode),POINTER :: node
  TYPE(ParamTypeIterator) :: iterator

  isValid = .TRUE.
  CALL iterator%activate(refList,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    IF(.NOT.this%has(prefix//iterator%name)) THEN
      message = modName//'::'//myName//' - Parameter "'//prefix//iterator%name// &
          '" is on the reference list but not on the test list!'
      CALL eParams%raiseError(CHAR(message))
      IF(assert) THEN
        ASSERT(.FALSE.,CHAR(message))
        CALL BACKTRACE()
      ENDIF
      isValid = .FALSE.
    ELSE
      CALL this%getNode_Name(prefix//iterator%name,node)
      IF(node%datatype /= iterator%node%dataType) THEN
        message = modName//'::'//myName//' - Parameter "'//prefix//iterator%name// &
            '" is type "'//paramTypeNames(iterator%node%dataType)//'" on reference list but type "'// &
            paramTypeNames(node%dataType)//'" on test list!'
        IF(assert) THEN
          ASSERT(.FALSE.,CHAR(message))
          CALL BACKTRACE()
        ELSE
          CALL eParams%raiseError(CHAR(message))
        ENDIF
        isValid = .FALSE.
      ELSE
        IF(ALLOCATED(iterator%node%val)) THEN
          SELECTTYPE(v => iterator%node%val)
          CLASS IS(ParamType)
            isValid = (isValid .AND. verify_helper(this,v,assert,fuzzy,structure,prefix//iterator%name//'->'))
          CLASS DEFAULT
            IF(.NOT.structure) THEN
              SELECTCASE(node%dataType)
              CASE(PL_DATA_TYPE_SSK0,PL_DATA_TYPE_SSK1,PL_DATA_TYPE_SSK2,PL_DATA_TYPE_SSK3, &
                  PL_DATA_TYPE_SSK4,PL_DATA_TYPE_SSK5,PL_DATA_TYPE_SSK6,PL_DATA_TYPE_SSK7, &
                  PL_DATA_TYPE_SDK0,PL_DATA_TYPE_SDK1,PL_DATA_TYPE_SDK2,PL_DATA_TYPE_SDK3, &
                  PL_DATA_TYPE_SDK4,PL_DATA_TYPE_SDK5,PL_DATA_TYPE_SDK6,PL_DATA_TYPE_SDK7)
                IF(PRESENT(fuzzy)) THEN
                  localValid = SOFTEQ_Param(node%val,iterator%node%val,fuzzy)
                ELSE
                  localValid = (node%val == iterator%node%val)
                ENDIF
              CASE DEFAULT
                localValid = (node%val == iterator%node%val)
              ENDSELECT
            ELSE
              localValid = .TRUE.
            ENDIF
            IF(.NOT.localValid) THEN
              message = modName//'::'//myName//' - Parameter "'//prefix//iterator%name// &
                  '" has a different value on the test list than on the reference list!'
              IF(assert) THEN
                ASSERT(.FALSE.,CHAR(message))
                CALL BACKTRACE()
              ELSE
                CALL eParams%raiseError(CHAR(message))
              ENDIF
              isValid = .FALSE.
            ENDIF
          ENDSELECT
        ELSEIF(ALLOCATED(node%val)) THEN
          message = modName//'::'//myName//' - Parameter "'//prefix//iterator%name// &
              '" is allocated on the test list but not the reference list!'
          IF(assert) THEN
            ASSERT(.FALSE.,CHAR(message))
            CALL BACKTRACE()
          ELSE
            CALL eParams%raiseError(CHAR(message))
          ENDIF
          isValid = .FALSE.
        ENDIF
      ENDIF
    ENDIF
    CALL iterator%advance()
  ENDDO

ENDFUNCTION verify_helper
!
!-------------------------------------------------------------------------------
!> @brief Edits a @c ParamType to a text file
!> @param this the @c ParamType to edit
!> @param funit the unit number for the text file
!> @param indent the number of indentations preceding the parameter
!> @param prefix optional prefix to add before the datatype
!> @param paddtw optional whitespace padding to add before the datatype
!>
RECURSIVE SUBROUTINE editTreeToText(this,funit,indent,prefix,paddtw)
  CLASS(ParamType),INTENT(IN) :: this
  INTEGER(SIK),INTENT(IN) :: funit
  INTEGER(SIK),INTENT(IN),OPTIONAL :: indent
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: prefix
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: paddtw

  IF(ASSOCIATED(this%root)) THEN
    CALL this%root%editNodeToText(funit,indent,prefix,paddtw)
  ENDIF

ENDSUBROUTINE editTreeToText
!
!-------------------------------------------------------------------------------
!> @brief Edit a @c ParamType to an HDF5 file
!> @param this the @c ParamType to edit
!> @param file the @c HDF5FileType object to write to
!> @param path the location in @c file to write
!>
SUBROUTINE editToH5_Tree(this,file,path)
  CLASS(ParamType),INTENT(IN) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path
  !
  TYPE(StringType) :: name
  CLASS(ParamNode),POINTER :: node
  TYPE(ParamTypeIterator) :: iterator

  REQUIRE(file%isInit)

  CALL iterator%activate(this,SUBLISTS=.TRUE.)
  DO WHILE(iterator%isActive)
    name = iterator%getCurrentName()
    name = path//'->'//name
    IF(iterator%getCurrentType() == PL_DATA_TYPE_TREE) THEN
      CONTINUE
    ELSE
      node => iterator%getCurrentNode()
      CALL node%editNodeToH5(file,CHAR(name))
    ENDIF
    CALL iterator%advance()
  ENDDO

ENDSUBROUTINE editToH5_Tree
!
!-------------------------------------------------------------------------------
!> @brief Reads a @c ParamType from an HDF5 file
!> @param this the @c ParamType to read
!> @param file the @c HDF5FileType object to read from
!> @param path the location in @c file read from
!>
RECURSIVE SUBROUTINE readFromH5_Tree(this,file,path)
  CLASS(ParamType),INTENT(INOUT) :: this
  CLASS(HDF5FileType),INTENT(INOUT) :: file
  CHARACTER(LEN=*),INTENT(IN) :: path
  !
  INTEGER(SIK) :: i,rank
  INTEGER(SIK),ALLOCATABLE :: dataShape(:)
  TYPE(StringType) :: converted_path,dataset_path,dataType
  TYPE(StringType),ALLOCATABLE :: datasets(:)
  CLASS(ParamNode),POINTER :: node

  REQUIRE(file%isInit)

  !Convert the path from HDF5 format to PL
  converted_path = TRIM(ADJUSTL(path))
  IF(converted_path%substr(1,1) == '/') THEN
    converted_path = converted_path%substr(2)
  ENDIF
  converted_path = converted_path%replace('/','->')

  !Loop over the list of datasets in the path
  CALL file%ls(CHAR(converted_path),datasets)
  DO i=1,SIZE(datasets)
    node => NULL()
    IF(LEN_TRIM(converted_path) > 0) THEN
      dataset_path = converted_path//'->'//datasets(i)
    ELSE
      dataset_path = datasets(i)
    ENDIF
    !Create the node and get some metadata so we can initialize the node
    CALL this%getOrCreateNode_Name(CHAR(datasets(i)),node,.FALSE.)
    IF(file%isGroup(CHAR(dataset_path))) THEN
      dataType = 'Tree'
      rank = 0
    ELSE
      dataType = file%getDataType(TRIM(dataset_path))
      dataShape = file%getDataShape(TRIM(dataset_path))
      rank = SIZE(dataShape)
    ENDIF
    CALL node%readNodeFromH5(file,CHAR(dataset_path),dataType,rank)
    SELECTTYPE(v => node%val); CLASS IS(ParamType)
      CALL v%readFromH5(file,CHAR(dataset_path))
    ENDSELECT
  ENDDO !i

ENDSUBROUTINE readFromH5_Tree
!
!-------------------------------------------------------------------------------
!> @brief Converts a @c ParamType to a @c XMLElementType
!> @param this the @c ParamType to convert
!> @param currElem the resulting @c XMLElementType
!>
RECURSIVE SUBROUTINE paramToXML(this,currElem)
  CLASS(ParamType),INTENT(IN) :: this
  TYPE(XMLElementType),POINTER,INTENT(INOUT) :: currElem(:)
  !
  CHARACTER(LEN=*),PARAMETER :: myName='paramToXML'
  CHARACTER(LEN=128) :: tmpchar
  INTEGER(SIK) :: nElem,i
  TYPE(StringType) :: val,name,typename
  TYPE(StringType),ALLOCATABLE :: str1(:)
  TYPE(XMLElementType),POINTER :: myChildren(:)
  CLASS(ParamNode),POINTER :: node
  TYPE(ParamTypeIterator) :: iterator

  IF(.NOT.ASSOCIATED(this%root)) RETURN

  nElem = 0
  CALL iterator%activate(this,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    nElem = nElem + 1
    CALL iterator%advance()
  ENDDO
  ALLOCATE(currElem(nElem))

  nElem = 0
  CALL iterator%activate(this,SUBLISTS=.FALSE.)
  DO WHILE(iterator%isActive)
    name = 'Parameter'
    nElem = nElem + 1
    node => iterator%getCurrentNode()
    SELECTTYPE(ptr => node%val)
    TYPE IS(ParamType)
      myChildren => NULL()
      CALL paramToXML(ptr,myChildren)
      name = 'ParameterList'
      typename = ''
      val = ''
      CALL currElem(nElem)%setChildren(myChildren)
      myChildren => NULL()
    TYPE IS(Param_SBK0)
      typename = 'bool'
      val = TRIM(MERGE('true ','false',ptr%p))
    TYPE IS(Param_SNK0)
      typename = 'int'
      val = str(ptr%p)
    TYPE IS(Param_SSK0)
      typename = 'float'
      WRITE(tmpchar,'(es14.6)') ptr%P
      val = TRIM(ADJUSTL(tmpchar))
    TYPE IS(Param_SDK0)
      typename = 'double'
      WRITE(tmpchar,'(es23.15)') ptr%P
      val = TRIM(ADJUSTL(tmpchar))
    TYPE IS(Param_Str0)
      typename = 'string'
      val = ptr%p
    TYPE IS(Param_SNK1)
      typename = 'Array(int)'
      ALLOCATE(str1(SIZE(ptr%p)))
      DO i = 1,SIZE(ptr%p)
        str1(i) = str(ptr%p(i))
      ENDDO !i
      CALL string_array_to_string(str1,val)
      DEALLOCATE(str1)
    TYPE IS(Param_SDK1)
      typename = 'Array(double)'
      ALLOCATE(str1(SIZE(ptr%p)))
      DO i = 1,SIZE(ptr%p)
        WRITE(tmpchar,'(ES23.15)') ptr%p(i)
        str1(i) = TRIM(ADJUSTL(tmpchar))
      ENDDO !i
      CALL string_array_to_string(str1,val)
      DEALLOCATE(str1)
    TYPE IS(Param_Str1)
      typename = 'Array(string)'
      str1 = ptr%p(:)
      CALL string_array_to_string(str1,val)
      DEALLOCATE(str1)
    CLASS DEFAULT
      CALL eParams%raiseError('Invalid paramType in '//modName//'::'//myName// &
          ' - dataType '//TRIM(paramTypeNames(iterator%getCurrentType()))//' is not valid for XML output!')
    ENDSELECT
    CALL currElem(nElem)%setname(name)
    CALL currElem(nElem)%setAttribute(StringType('name'),iterator%getCurrentName())
    IF(LEN_TRIM(typename) > 0) CALL currElem(nElem)%setAttribute(StringType('type'),typename)
    IF(LEN_TRIM(val) > 0) CALL currElem(nElem)%setAttribute(StringType('value'),val)
    CALL iterator%advance()
  ENDDO

ENDSUBROUTINE paramToXML
!
!-------------------------------------------------------------------------------
!> @brief Writes a @c ParamType to an XLM file
!> @param this the @c ParamType to write
!> @param fname the name of th eXML file to create
!>
SUBROUTINE editToXML(this,fname)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: fname
  !
  TYPE(XMLFileType) :: xmlFile

  REQUIRE(ASSOCIATED(this%root))

  xmlFile%style_sheet = 'PL9.xsl'

  CALL paramToXML(this,xmlFile%root)

  CALL xmlFile%exportToDisk(fname)
  CALL xmlFile%clear()

ENDSUBROUTINE editToXML
!
!-------------------------------------------------------------------------------
!> @brief Defines the operation for performing an assignment of an array of
!> strings to a string single string
!> @param sArr the array of strings
!> @param str the string value
!>
!> The formatting of the resulting string is for XML output
!>
SUBROUTINE string_array_to_string(sArr,str)
  TYPE(StringType),INTENT(IN) :: sArr(:)
  TYPE(StringType),INTENT(OUT) :: str
  INTEGER(SIK) :: i,numElts

  numElts=SIZE(sArr)
  str=''
  IF(numElts == 0) RETURN

  str='{'
  DO i=1,numElts
    str=TRIM(str)//TRIM(sArr(i))
    IF(i < numElts) str=TRIM(str)//','
  ENDDO
  str=TRIM(str)//'}'
ENDSUBROUTINE string_array_to_string
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a node from a tree
!> @param this the @c ParamType to search
!> @param hash the hash of the node's name
!> @param node pointer to the node
!> @param node_parent pointer to the node's parent node
!>
SUBROUTINE getTreeNode(this,hash,node,node_parent)
  CLASS(ParamType),INTENT(IN) :: this
  INTEGER(SLK),INTENT(IN) :: hash
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node_parent

  !This is going to search for a node that matches the name in hash.
  !We also keep track of the parent node and the relationship between them
  !for use after the search
  node_parent => NULL()
  node => this%root
  DO WHILE(ASSOCIATED(node))
    IF(hash < node%upperNameHash) THEN
      node_parent => node
      node => node%left
    ELSEIF(hash > node%upperNameHash) THEN
      node_parent => node
      node => node%right
    ELSEIF(hash == node%upperNameHash) THEN
      EXIT
    ENDIF
  ENDDO

ENDSUBROUTINE getTreeNode
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a node from a tree, or creates it if it was not found
!> @param this the @c ParamType to search
!> @param name the name of the node to get or create
!> @param node the pointer to the node
!> @param depthSearch indicates whether to search recursively through lower level
!>        @c ParamType nodes for @c name
!>
SUBROUTINE getOrCreateNode_Name(this,name,node,depthSearch)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node
  LOGICAL(SBK),INTENT(IN) :: depthSearch
  !
  CHARACTER(LEN=*),PARAMETER :: myName='getOrCreateNode_Name'
  INTEGER(SLK),ALLOCATABLE :: hashes(:)
  TYPE(StringType) :: tmpname
  TYPE(StringType),ALLOCATABLE :: names(:)

  !Convert the name/path to an array of path elements and hash them
  tmpname = name
  names = tmpname%split('->')
  CALL get_hash_list(names,hashes)
  IF(ANY(hashes == 0)) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Cannot search for or create a parameter with an empty name!')
    node => NULL()
    RETURN
  ENDIF

  CALL getOrCreateNode_Hashes(this,hashes,names,node,(SIZE(hashes) == 1) .AND. depthSearch)

ENDSUBROUTINE getOrCreateNode_Name
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a node from a tree, or creates it if it was not found
!> @param this the @c ParamType to search
!> @param hashes array of hashes corresponding to the tree levels to search through
!> @param names array of names corresponding to the tree levels to search through
!> @param node the pointer to the node
!> @param depthSearch indicates whether to search recursively through lower level
!>        @c ParamType nodes for @c name
!>
RECURSIVE SUBROUTINE getOrCreateNode_Hashes(this,hashes,names,node,depthSearch)
  CLASS(ParamType),INTENT(INOUT) :: this
  INTEGER(SLK),INTENT(IN) :: hashes(:)
  TYPE(StringType),INTENT(IN) :: names(:)
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node
  LOGICAL(SBK),INTENT(IN) :: depthSearch
  !
  CLASS(ParamNode),POINTER :: node_parent
  TYPE(ParamTypeIterator) :: iterator

  CALL this%getTreeNode(hashes(1),node,node_parent)

  !If not associated, then search recursively if depthSearch is true
  IF(.NOT.ASSOCIATED(node) .AND. depthSearch) THEN
    CALL iterator%activate(this,SUBLISTS=.TRUE.)
    DO WHILE(.NOT.ASSOCIATED(node) .AND. iterator%isActive)
      IF(iterator%dataType == PL_DATA_TYPE_TREE) THEN
        SELECTTYPE(p => iterator%node%val); TYPE IS(ParamType)
          CALL p%getNode_Hashes(hashes,node,depthSearch)
        ENDSELECT
      ENDIF
      CALL iterator%advance()
    ENDDO
  ENDIF

  !Not associated means we couldn't find a node that matched the desired name.
  !Since left and right get allocated but not initialized when their parent
  !is initialized, this means there are two cases.  1) This is a new tree
  !whose root was not allocated yet, or 2) node will be unassociated, but node_parent
  !will be pointing to the location in the tree where we expected to find hash(1)
  !
  !If we're creating new nodes, the new node should go at node_parent's location
  !otherwise we'll just leave node associated with NULL().
  IF(.NOT.ASSOCIATED(node)) THEN
    !If the parent is associated then a location exists for the node but has not been initialized.
    !Otherwise, the tree is empty and we nee dto set up the root.
    IF(ASSOCIATED(node_parent)) THEN
      IF(hashes(1) < node_parent%upperNameHash) THEN
        ALLOCATE(node_parent%left)
        node => node_parent%left
      ELSE
        ALLOCATE(node_parent%right)
        node => node_parent%right
      ENDIF
      node%parent => node_parent
    ELSE
      ALLOCATE(this%root)
      node => this%root
    ENDIF
    !If this is just the top of a list, create the list and continue the searching
    IF(SIZE(hashes) > 1) THEN
      CALL node%initTree(CHAR(names(1)))
    ELSE
      CALL node%initBase(CHAR(names(1)))
    ENDIF
  ENDIF

  !If the node is associated that means we either found it or just created it.  If
  !that's the case and there are still path elements remaining, make a recursive call.
  !Otherwise, we'll just return the node we've found/created.
  IF(ASSOCIATED(node) .AND. SIZE(hashes) > 1) THEN
    SELECTTYPE(val => node%val); TYPE IS(ParamType)
      CALL val%getOrCreateNode_Hashes(hashes(2:),names(2:),node,.FALSE.)
    ENDSELECT
  ENDIF

ENDSUBROUTINE getOrCreateNode_Hashes
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a node from a tree
!> @param this the @c ParamType to search
!> @param name the name of the node to search for
!> @param node the pointer to the node
!>
SUBROUTINE getNode_Name(this,name,node)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node
  !
  CHARACTER(LEN=*),PARAMETER :: myName='getNode_Name'
  INTEGER(SLK),ALLOCATABLE :: hashes(:)
  TYPE(StringType) :: tmpname
  TYPE(StringType),ALLOCATABLE :: names(:)

  !Convert the name/path to an array of path elements and hash them
  tmpname = name
  names = tmpname%split('->')
  CALL get_hash_list(names,hashes)
  IF(ANY(hashes == 0)) THEN
    CALL eParams%raiseError(modName//'::'//myName//' - Cannot search for a parameter with an empty name!')
    node => NULL()
    RETURN
  ENDIF

  CALL this%getNode_Hashes(hashes,node, .TRUE.)

ENDSUBROUTINE getNode_Name
!
!-------------------------------------------------------------------------------
!> @brief Retrieves a node from a tree
!> @param this the @c ParamType to search
!> @param hashes the list of hashes identifying the path to the node
!> @param node the pointer to the node
!> @param depthSearch indicates whether to search recursively through lower level
!>        @c ParamType nodes for @c name
!>
RECURSIVE SUBROUTINE getNode_Hashes(this,hashes,node,depthSearch)
  CLASS(ParamType),INTENT(IN) :: this
  INTEGER(SLK),INTENT(IN) :: hashes(:)
  CLASS(ParamNode),POINTER,INTENT(OUT) :: node
  LOGICAL(SBK),INTENT(IN) :: depthSearch
  !
  CLASS(ParamNode),POINTER :: node_parent
  TYPE(ParamTypeIterator) :: iterator

  CALL this%getTreeNode(hashes(1),node,node_parent)

  !If the node is associated that means we found it.  If
  !that's the case and there are still path elements remaining, make a recursive call.
  !Otherwise, we'll just return the node we've found.
  IF(ASSOCIATED(node) .AND. SIZE(hashes) > 1) THEN
    SELECTTYPE(val => node%val); TYPE IS(ParamType)
      CALL val%getNode_Hashes(hashes(2:),node,.FALSE.)
    ENDSELECT
  ELSEIF(.NOT.ASSOCIATED(node) .AND. depthSearch) THEN
    CALL iterator%activate(this,SUBLISTS=.FALSE.)
    DO WHILE(.NOT.ASSOCIATED(node) .AND. iterator%isActive)
      IF(iterator%getCurrentType() == PL_DATA_TYPE_TREE) THEN
        SELECTTYPE(p => iterator%node%val); TYPE IS(ParamType)
          CALL p%getNode_Hashes(hashes,node,.TRUE.)
        ENDSELECT
      ENDIF
      CALL iterator%advance()
    ENDDO
    CALL iterator%clear()
  ENDIF

ENDSUBROUTINE getNode_Hashes
!
!-------------------------------------------------------------------------------
!> @brief Edits a @c ParamType to a text file
!> @param this the @c ParamType to edit
!> @param funit the file unit number
!> @param indent the number of indentations preceding the parameter
!> @param prefix optional prefix to add before the datatype
!> @param shift unused
!> @param description the description to append to the parameter edit
!> @param paddtw optional whitespace padding to add before the datatype
!>
RECURSIVE SUBROUTINE editToText_Tree(this,funit,indent,prefix,shift,description,paddtw)
  CLASS(ParamType),INTENT(IN) :: this
  INTEGER(SIK),INTENT(IN) :: funit
  INTEGER(SIK),INTENT(IN) :: indent
  TYPE(StringType),INTENT(IN) :: prefix
  INTEGER(SIK),INTENT(IN) :: shift
  CHARACTER(LEN=*),INTENT(IN) :: description
  LOGICAL(SBK),INTENT(IN) :: paddtw

  WRITE(UNIT=funit,FMT='(a)') ' ! '//description
  CALL this%edit(funit,indent+3,CHAR(prefix),paddtw)

ENDSUBROUTINE editToText_Tree
!
!===============================================================================
! Methods to initialize non-templatable data types
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Initializes a rank-0 parameter container of type CHARACTER(LEN=*)
!> @param this the node to initialize data on
!> @param name the name of the parameter to initialize
!> @param val the values to use for initializing the node
!> @param description the description of the value; optional
!>
SUBROUTINE initCHAR(this,name,val,description)
  CLASS(ParamNode),TARGET,INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=*),INTENT(IN) :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description

  IF(.NOT.ALLOCATED(this%val)) THEN
    CALL this%initBase(name,description)
    this%dataType = PL_DATA_TYPE_STR0
    ALLOCATE(Param_STR0 :: this%val)
  ENDIF
  SELECTTYPE(ptr => this%val); TYPE IS(Param_STR0)
    ptr%p = val
  ENDSELECT

ENDSUBROUTINE initCHAR
!
!-------------------------------------------------------------------------------
!
!===============================================================================
! Methods to add non-templatable data types
!===============================================================================
#include "parameter_list_includes/parameterListAddNode.f90"
!
!-------------------------------------------------------------------------------
!> @brief Adds a @c ParamType as a sublist to another @c ParamType
!> @param this the target @c ParamType
!> @param name the name of the node to add the sublist too
!> @param val the source @c ParamType
!> @param description the description of the new node; optional, defaults to empty string
!>
SUBROUTINE addTree(this,name,val,description)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  TYPE(ParamType),INTENT(IN) :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description
  !
  TYPE(StringType) :: strname
  TYPE(ParamTypeIterator) :: iterator

  CALL iterator%activate(val,sublists=.TRUE.)
  DO WHILE(iterator%isActive)
    strname = iterator%getCurrentName()
    strname = name//'->'//strname
    CALL this%add(CHAR(strname),iterator%getCurrentNode())
    CALL iterator%advance()
  ENDDO

ENDSUBROUTINE addTree
!
!===============================================================================
! Methods to get non-templatable data types
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Gets a rank-0 parameter of type CHARACTER(LEN=*)
!> @param this the node to get data from
!> @param name the name of the parameter to get
!> @param val the values retrieved from the node
!> @param default the value to assign to @c val if the parameter is not found; optional
!>
!> If the parameter is not found and @c default is not provided, an error is thrown.
!>
SUBROUTINE getCHAR(this,name,val,default)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=:),ALLOCATABLE,INTENT(OUT) :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: default
  !
  CLASS(ParamNode),POINTER :: node

  CALL this%getNode_Name(name,node)
  IF(errorChecks_get(node,PRESENT(default),name,PL_DATA_TYPE_STR0) == 0) THEN
    IF(ASSOCIATED(node)) THEN
      SELECTTYPE(ptr => node%val); TYPE IS(Param_STR0)
        val=CHAR(ptr%p)
      ENDSELECT
    ELSE
      val=default
    ENDIF
  ENDIF

ENDSUBROUTINE getCHAR
!
!-------------------------------------------------------------------------------
!> @brief Gets a rank-0 parameter of type TYPE(StringType)
!> @param this the node to get data from
!> @param name the name of the parameter to get
!> @param val the values retrieved from the node
!> @param default the value to assign to @c val if the parameter is not found; optional
!>
!> If the parameter is not found and @c default is not provided, an error is thrown.
!>
SUBROUTINE getStrChar(this,name,val,default)
  CLASS(ParamType),INTENT(IN) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  TYPE(StringType),INTENT(OUT) :: val
  CHARACTER(LEN=*),INTENT(IN) :: default
  !
  TYPE(StringType) :: strdefault

  strdefault = default
  CALL this%get(name,val,strdefault)

ENDSUBROUTINE getStrChar
!
!===============================================================================
! Methods to add non-templatable data types
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Adds a rank-0 parameter of type CHARACTER(LEN=*)
!> @param this the node to add data to
!> @param name the name of the parameter to set
!> @param val the values to add to the parameter
!> @param description the description of the value; optional
!>
SUBROUTINE addCHAR(this,name,val,description)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=*),INTENT(IN) :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description
  !
  CLASS(ParamNode),POINTER :: node

  CALL this%getOrCreateNode_Name(name,node,.TRUE.)
  IF(errorChecks_add(node,name,PL_DATA_TYPE_STR0) == 0) THEN
    CALL node%initCHAR(CHAR(node%name),val,description)
  ENDIF

ENDSUBROUTINE addCHAR
!
!===============================================================================
! Methods to set non-templatable data types
!===============================================================================
!
!-------------------------------------------------------------------------------
!> @brief Sets a rank-0 parameter of type CHARACTER(LEN=*)
!> @param this the node to set data on
!> @param name the name of the parameter to set
!> @param val the values to set to the parameter
!> @param addmissing logical to indicate if the parameter should be created if not found; optional
!>
!> If the parameter is not found and @c addmissing is not set to true, an error is thrown.
!>
SUBROUTINE setCHAR(this,name,val,description,addmissing)
  CLASS(ParamType),INTENT(INOUT) :: this
  CHARACTER(LEN=*),INTENT(IN) :: name
  CHARACTER(LEN=*),INTENT(IN) :: val
  CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: description
  LOGICAL(SBK),INTENT(IN),OPTIONAL :: addmissing
  !
  LOGICAL(SBK) :: laddmissing
  CLASS(ParamNode),POINTER :: node

  laddmissing=.FALSE.
  IF(PRESENT(addmissing)) laddmissing=addmissing
  IF(laddmissing) THEN
    CALL this%getOrCreateNode_Name(name,node,.TRUE.)
  ELSE
    CALL this%getNode_Name(name,node)
  ENDIF
  IF(errorChecks_set(node,laddmissing,name,PL_DATA_TYPE_STR0) == 0) THEN
    CALL node%initCHAR(CHAR(node%name),val,description)
  ENDIF

ENDSUBROUTINE setCHAR
!
!===============================================================================
! Include files for procedures templated by generateParameterListClasses.py
!===============================================================================
!
#include "parameter_list_includes/parameterListH5read.f90"
#include "parameter_list_includes/parameterListMethods.f90"
!
ENDMODULE ParameterLists
